<?php
/**
 * MxPlatformApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MX Platform API
 *
 * The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * MxPlatformApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UserApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'aggregateMember' => [
            'application/json',
        ],
        'checkBalances' => [
            'application/json',
        ],
        'createManagedAccount' => [
            'application/json',
        ],
        'createManagedMember' => [
            'application/json',
        ],
        'createManualAccount' => [
            'application/json',
        ],
        'createMember' => [
            'application/json',
        ],
        'createTag' => [
            'application/json',
        ],
        'createTagging' => [
            'application/json',
        ],
        'createUser' => [
            'application/json',
        ],
        'creditCard' => [
            'application/json',
        ],
        'deleteManagedAccount' => [
            'application/json',
        ],
        'deleteManagedMember' => [
            'application/json',
        ],
        'deleteManualAccount' => [
            'application/json',
        ],
        'deleteMember' => [
            'application/json',
        ],
        'deleteTag' => [
            'application/json',
        ],
        'deleteTagging' => [
            'application/json',
        ],
        'deleteUser' => [
            'application/json',
        ],
        'deprecatedRequestPaymentProcessorAuthorizationCode' => [
            'application/json',
        ],
        'downloadStatementPDF' => [
            'application/json',
        ],
        'downloadTaxDocument' => [
            'application/json',
        ],
        'extendHistory' => [
            'application/json',
        ],
        'fetchRewards' => [
            'application/json',
        ],
        'fetchStatements' => [
            'application/json',
        ],
        'fetchTaxDocuments' => [
            'application/json',
        ],
        'identifyMember' => [
            'application/json',
        ],
        'listAccountNumbersByAccount' => [
            'application/json',
        ],
        'listAccountNumbersByMember' => [
            'application/json',
        ],
        'listAccountOwnersByMember' => [
            'application/json',
        ],
        'listCategories' => [
            'application/json',
        ],
        'listDefaultCategories' => [
            'application/json',
        ],
        'listDefaultCategoriesByUser' => [
            'application/json',
        ],
        'listFavoriteInstitutions' => [
            'application/json',
        ],
        'listHoldings' => [
            'application/json',
        ],
        'listHoldingsByAccount' => [
            'application/json',
        ],
        'listHoldingsByMember' => [
            'application/json',
        ],
        'listInstitutionCredentials' => [
            'application/json',
        ],
        'listInstitutions' => [
            'application/json',
        ],
        'listManagedAccounts' => [
            'application/json',
        ],
        'listManagedInstitutions' => [
            'application/json',
        ],
        'listManagedMembers' => [
            'application/json',
        ],
        'listMemberAccounts' => [
            'application/json',
        ],
        'listMemberChallenges' => [
            'application/json',
        ],
        'listMemberCredentials' => [
            'application/json',
        ],
        'listMembers' => [
            'application/json',
        ],
        'listMerchants' => [
            'application/json',
        ],
        'listRewards' => [
            'application/json',
        ],
        'listStatementsByMember' => [
            'application/json',
        ],
        'listTaggings' => [
            'application/json',
        ],
        'listTags' => [
            'application/json',
        ],
        'listTaxDocuments' => [
            'application/json',
        ],
        'listUserAccounts' => [
            'application/json',
        ],
        'listUsers' => [
            'application/json',
        ],
        'readAccount' => [
            'application/json',
        ],
        'readAccountByMember' => [
            'application/json',
        ],
        'readHolding' => [
            'application/json',
        ],
        'readInstitution' => [
            'application/json',
        ],
        'readManagedAccount' => [
            'application/json',
        ],
        'readManagedMember' => [
            'application/json',
        ],
        'readMember' => [
            'application/json',
        ],
        'readMemberStatus' => [
            'application/json',
        ],
        'readMerchant' => [
            'application/json',
        ],
        'readMerchantLocation' => [
            'application/json',
        ],
        'readRewards' => [
            'application/json',
        ],
        'readStatementByMember' => [
            'application/json',
        ],
        'readTag' => [
            'application/json',
        ],
        'readTagging' => [
            'application/json',
        ],
        'readTaxDocument' => [
            'application/json',
        ],
        'readUser' => [
            'application/json',
        ],
        'requestAuthorizationCode' => [
            'application/json',
        ],
        'requestConnectWidgetURL' => [
            'application/json',
        ],
        'requestOAuthWindowURI' => [
            'application/json',
        ],
        'requestWidgetURL' => [
            'application/json',
        ],
        'resumeAggregation' => [
            'application/json',
        ],
        'updateAccountByMember' => [
            'application/json',
        ],
        'updateCategory' => [
            'application/json',
        ],
        'updateManagedAccount' => [
            'application/json',
        ],
        'updateManagedMember' => [
            'application/json',
        ],
        'updateMember' => [
            'application/json',
        ],
        'updateTag' => [
            'application/json',
        ],
        'updateTagging' => [
            'application/json',
        ],
        'updateUser' => [
            'application/json',
        ],
        'usersUserGuidMonthlyCashFlowProfileGet' => [
            'application/json',
        ],
        'usersUserGuidMonthlyCashFlowProfilePut' => [
            'application/json',
        ],
        'verifyMember' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation aggregateMember
     *
     * Aggregate member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aggregateMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function aggregateMember($member_guid, $user_guid, string $contentType = self::contentTypes['aggregateMember'][0])
    {
        list($response) = $this->aggregateMemberWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation aggregateMemberWithHttpInfo
     *
     * Aggregate member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aggregateMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function aggregateMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['aggregateMember'][0])
    {
        $request = $this->aggregateMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation aggregateMemberAsync
     *
     * Aggregate member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aggregateMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aggregateMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['aggregateMember'][0])
    {
        return $this->aggregateMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation aggregateMemberAsyncWithHttpInfo
     *
     * Aggregate member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aggregateMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aggregateMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['aggregateMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->aggregateMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'aggregateMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aggregateMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function aggregateMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['aggregateMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling aggregateMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling aggregateMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/aggregate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkBalances
     *
     * Check balances
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkBalances'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function checkBalances($member_guid, $user_guid, string $contentType = self::contentTypes['checkBalances'][0])
    {
        list($response) = $this->checkBalancesWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation checkBalancesWithHttpInfo
     *
     * Check balances
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkBalances'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkBalancesWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['checkBalances'][0])
    {
        $request = $this->checkBalancesRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkBalancesAsync
     *
     * Check balances
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkBalancesAsync($member_guid, $user_guid, string $contentType = self::contentTypes['checkBalances'][0])
    {
        return $this->checkBalancesAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkBalancesAsyncWithHttpInfo
     *
     * Check balances
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkBalancesAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['checkBalances'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->checkBalancesRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkBalances'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkBalancesRequest($member_guid, $user_guid, string $contentType = self::contentTypes['checkBalances'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling checkBalances'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling checkBalances'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/check_balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createManagedAccount
     *
     * Create managed account
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountCreateRequestBody $managed_account_create_request_body Managed account to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function createManagedAccount($member_guid, $user_guid, $managed_account_create_request_body, string $contentType = self::contentTypes['createManagedAccount'][0])
    {
        list($response) = $this->createManagedAccountWithHttpInfo($member_guid, $user_guid, $managed_account_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createManagedAccountWithHttpInfo
     *
     * Create managed account
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountCreateRequestBody $managed_account_create_request_body Managed account to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManagedAccountWithHttpInfo($member_guid, $user_guid, $managed_account_create_request_body, string $contentType = self::contentTypes['createManagedAccount'][0])
    {
        $request = $this->createManagedAccountRequest($member_guid, $user_guid, $managed_account_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createManagedAccountAsync
     *
     * Create managed account
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountCreateRequestBody $managed_account_create_request_body Managed account to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManagedAccountAsync($member_guid, $user_guid, $managed_account_create_request_body, string $contentType = self::contentTypes['createManagedAccount'][0])
    {
        return $this->createManagedAccountAsyncWithHttpInfo($member_guid, $user_guid, $managed_account_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createManagedAccountAsyncWithHttpInfo
     *
     * Create managed account
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountCreateRequestBody $managed_account_create_request_body Managed account to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManagedAccountAsyncWithHttpInfo($member_guid, $user_guid, $managed_account_create_request_body, string $contentType = self::contentTypes['createManagedAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->createManagedAccountRequest($member_guid, $user_guid, $managed_account_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createManagedAccount'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountCreateRequestBody $managed_account_create_request_body Managed account to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createManagedAccountRequest($member_guid, $user_guid, $managed_account_create_request_body, string $contentType = self::contentTypes['createManagedAccount'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling createManagedAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling createManagedAccount'
            );
        }

        // verify the required parameter 'managed_account_create_request_body' is set
        if ($managed_account_create_request_body === null || (is_array($managed_account_create_request_body) && count($managed_account_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $managed_account_create_request_body when calling createManagedAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managed_account_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managed_account_create_request_body));
            } else {
                $httpBody = $managed_account_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createManagedMember
     *
     * Create managed member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberCreateRequestBody $managed_member_create_request_body Managed member to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function createManagedMember($user_guid, $managed_member_create_request_body, string $contentType = self::contentTypes['createManagedMember'][0])
    {
        list($response) = $this->createManagedMemberWithHttpInfo($user_guid, $managed_member_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createManagedMemberWithHttpInfo
     *
     * Create managed member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberCreateRequestBody $managed_member_create_request_body Managed member to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManagedMemberWithHttpInfo($user_guid, $managed_member_create_request_body, string $contentType = self::contentTypes['createManagedMember'][0])
    {
        $request = $this->createManagedMemberRequest($user_guid, $managed_member_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createManagedMemberAsync
     *
     * Create managed member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberCreateRequestBody $managed_member_create_request_body Managed member to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManagedMemberAsync($user_guid, $managed_member_create_request_body, string $contentType = self::contentTypes['createManagedMember'][0])
    {
        return $this->createManagedMemberAsyncWithHttpInfo($user_guid, $managed_member_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createManagedMemberAsyncWithHttpInfo
     *
     * Create managed member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberCreateRequestBody $managed_member_create_request_body Managed member to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManagedMemberAsyncWithHttpInfo($user_guid, $managed_member_create_request_body, string $contentType = self::contentTypes['createManagedMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->createManagedMemberRequest($user_guid, $managed_member_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createManagedMember'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberCreateRequestBody $managed_member_create_request_body Managed member to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createManagedMemberRequest($user_guid, $managed_member_create_request_body, string $contentType = self::contentTypes['createManagedMember'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling createManagedMember'
            );
        }

        // verify the required parameter 'managed_member_create_request_body' is set
        if ($managed_member_create_request_body === null || (is_array($managed_member_create_request_body) && count($managed_member_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $managed_member_create_request_body when calling createManagedMember'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managed_member_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managed_member_create_request_body));
            } else {
                $httpBody = $managed_member_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createManualAccount
     *
     * Create manual account
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountCreateRequestBody $account_create_request_body Manual account object to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManualAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function createManualAccount($user_guid, $account_create_request_body, string $contentType = self::contentTypes['createManualAccount'][0])
    {
        list($response) = $this->createManualAccountWithHttpInfo($user_guid, $account_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createManualAccountWithHttpInfo
     *
     * Create manual account
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountCreateRequestBody $account_create_request_body Manual account object to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManualAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManualAccountWithHttpInfo($user_guid, $account_create_request_body, string $contentType = self::contentTypes['createManualAccount'][0])
    {
        $request = $this->createManualAccountRequest($user_guid, $account_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createManualAccountAsync
     *
     * Create manual account
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountCreateRequestBody $account_create_request_body Manual account object to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManualAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManualAccountAsync($user_guid, $account_create_request_body, string $contentType = self::contentTypes['createManualAccount'][0])
    {
        return $this->createManualAccountAsyncWithHttpInfo($user_guid, $account_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createManualAccountAsyncWithHttpInfo
     *
     * Create manual account
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountCreateRequestBody $account_create_request_body Manual account object to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManualAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManualAccountAsyncWithHttpInfo($user_guid, $account_create_request_body, string $contentType = self::contentTypes['createManualAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->createManualAccountRequest($user_guid, $account_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createManualAccount'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountCreateRequestBody $account_create_request_body Manual account object to be created. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createManualAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createManualAccountRequest($user_guid, $account_create_request_body, string $contentType = self::contentTypes['createManualAccount'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling createManualAccount'
            );
        }

        // verify the required parameter 'account_create_request_body' is set
        if ($account_create_request_body === null || (is_array($account_create_request_body) && count($account_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_create_request_body when calling createManualAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($account_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($account_create_request_body));
            } else {
                $httpBody = $account_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMember
     *
     * Create member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberCreateRequestBody $member_create_request_body Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody|\OpenAPI\Client\Model\MemberResponseBody
     */
    public function createMember($user_guid, $member_create_request_body, string $contentType = self::contentTypes['createMember'][0])
    {
        list($response) = $this->createMemberWithHttpInfo($user_guid, $member_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createMemberWithHttpInfo
     *
     * Create member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberCreateRequestBody $member_create_request_body Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody|\OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMemberWithHttpInfo($user_guid, $member_create_request_body, string $contentType = self::contentTypes['createMember'][0])
    {
        $request = $this->createMemberRequest($user_guid, $member_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMemberAsync
     *
     * Create member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberCreateRequestBody $member_create_request_body Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMemberAsync($user_guid, $member_create_request_body, string $contentType = self::contentTypes['createMember'][0])
    {
        return $this->createMemberAsyncWithHttpInfo($user_guid, $member_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMemberAsyncWithHttpInfo
     *
     * Create member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberCreateRequestBody $member_create_request_body Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMemberAsyncWithHttpInfo($user_guid, $member_create_request_body, string $contentType = self::contentTypes['createMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->createMemberRequest($user_guid, $member_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMember'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberCreateRequestBody $member_create_request_body Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMemberRequest($user_guid, $member_create_request_body, string $contentType = self::contentTypes['createMember'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling createMember'
            );
        }

        // verify the required parameter 'member_create_request_body' is set
        if ($member_create_request_body === null || (is_array($member_create_request_body) && count($member_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_create_request_body when calling createMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($member_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($member_create_request_body));
            } else {
                $httpBody = $member_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTag
     *
     * Create tag
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagCreateRequestBody $tag_create_request_body Tag object to be created with required parameters (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TagResponseBody
     */
    public function createTag($user_guid, $tag_create_request_body, string $contentType = self::contentTypes['createTag'][0])
    {
        list($response) = $this->createTagWithHttpInfo($user_guid, $tag_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createTagWithHttpInfo
     *
     * Create tag
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagCreateRequestBody $tag_create_request_body Tag object to be created with required parameters (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TagResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTagWithHttpInfo($user_guid, $tag_create_request_body, string $contentType = self::contentTypes['createTag'][0])
    {
        $request = $this->createTagRequest($user_guid, $tag_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TagResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TagResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TagResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTagAsync
     *
     * Create tag
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagCreateRequestBody $tag_create_request_body Tag object to be created with required parameters (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagAsync($user_guid, $tag_create_request_body, string $contentType = self::contentTypes['createTag'][0])
    {
        return $this->createTagAsyncWithHttpInfo($user_guid, $tag_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTagAsyncWithHttpInfo
     *
     * Create tag
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagCreateRequestBody $tag_create_request_body Tag object to be created with required parameters (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagAsyncWithHttpInfo($user_guid, $tag_create_request_body, string $contentType = self::contentTypes['createTag'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TagResponseBody';
        $request = $this->createTagRequest($user_guid, $tag_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTag'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagCreateRequestBody $tag_create_request_body Tag object to be created with required parameters (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTagRequest($user_guid, $tag_create_request_body, string $contentType = self::contentTypes['createTag'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling createTag'
            );
        }

        // verify the required parameter 'tag_create_request_body' is set
        if ($tag_create_request_body === null || (is_array($tag_create_request_body) && count($tag_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_create_request_body when calling createTag'
            );
        }


        $resourcePath = '/users/{user_guid}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_create_request_body));
            } else {
                $httpBody = $tag_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTagging
     *
     * Create tagging
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingCreateRequestBody $tagging_create_request_body Tagging object to be created with required parameters (tag_guid and transaction_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaggingResponseBody
     */
    public function createTagging($user_guid, $tagging_create_request_body, string $contentType = self::contentTypes['createTagging'][0])
    {
        list($response) = $this->createTaggingWithHttpInfo($user_guid, $tagging_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createTaggingWithHttpInfo
     *
     * Create tagging
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingCreateRequestBody $tagging_create_request_body Tagging object to be created with required parameters (tag_guid and transaction_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaggingResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaggingWithHttpInfo($user_guid, $tagging_create_request_body, string $contentType = self::contentTypes['createTagging'][0])
    {
        $request = $this->createTaggingRequest($user_guid, $tagging_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TaggingResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TaggingResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaggingResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTaggingAsync
     *
     * Create tagging
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingCreateRequestBody $tagging_create_request_body Tagging object to be created with required parameters (tag_guid and transaction_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaggingAsync($user_guid, $tagging_create_request_body, string $contentType = self::contentTypes['createTagging'][0])
    {
        return $this->createTaggingAsyncWithHttpInfo($user_guid, $tagging_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaggingAsyncWithHttpInfo
     *
     * Create tagging
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingCreateRequestBody $tagging_create_request_body Tagging object to be created with required parameters (tag_guid and transaction_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaggingAsyncWithHttpInfo($user_guid, $tagging_create_request_body, string $contentType = self::contentTypes['createTagging'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TaggingResponseBody';
        $request = $this->createTaggingRequest($user_guid, $tagging_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTagging'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingCreateRequestBody $tagging_create_request_body Tagging object to be created with required parameters (tag_guid and transaction_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTaggingRequest($user_guid, $tagging_create_request_body, string $contentType = self::contentTypes['createTagging'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling createTagging'
            );
        }

        // verify the required parameter 'tagging_create_request_body' is set
        if ($tagging_create_request_body === null || (is_array($tagging_create_request_body) && count($tagging_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagging_create_request_body when calling createTagging'
            );
        }


        $resourcePath = '/users/{user_guid}/taggings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tagging_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tagging_create_request_body));
            } else {
                $httpBody = $tagging_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUser
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UserCreateRequestBody $user_create_request_body User object to be created. (None of these parameters are required, but the user object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserResponseBody
     */
    public function createUser($user_create_request_body, string $contentType = self::contentTypes['createUser'][0])
    {
        list($response) = $this->createUserWithHttpInfo($user_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createUserWithHttpInfo
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UserCreateRequestBody $user_create_request_body User object to be created. (None of these parameters are required, but the user object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUserWithHttpInfo($user_create_request_body, string $contentType = self::contentTypes['createUser'][0])
    {
        $request = $this->createUserRequest($user_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UserResponseBody',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UserResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Operation createUserAsync
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UserCreateRequestBody $user_create_request_body User object to be created. (None of these parameters are required, but the user object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUserAsync($user_create_request_body, string $contentType = self::contentTypes['createUser'][0])
    {
        return $this->createUserAsyncWithHttpInfo($user_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUserAsyncWithHttpInfo
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UserCreateRequestBody $user_create_request_body User object to be created. (None of these parameters are required, but the user object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUserAsyncWithHttpInfo($user_create_request_body, string $contentType = self::contentTypes['createUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UserResponseBody';
        $request = $this->createUserRequest($user_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUser'
     *
     * @param  \OpenAPI\Client\Model\UserCreateRequestBody $user_create_request_body User object to be created. (None of these parameters are required, but the user object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createUserRequest($user_create_request_body, string $contentType = self::contentTypes['createUser'][0])
    {
        // verify the required parameter 'user_create_request_body' is set
        if ($user_create_request_body === null || (is_array($user_create_request_body) && count($user_create_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_create_request_body when calling createUser'
            );
        }

        $resourcePath = '/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_create_request_body));
            } else {
                $httpBody = $user_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditCard
     *
     * Read a Credit Card Product
     *
     * @param  string $credit_card_product_guid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditCard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreditCardProductResponse
     */
    public function creditCard($credit_card_product_guid, string $contentType = self::contentTypes['creditCard'][0])
    {
        list($response) = $this->creditCardWithHttpInfo($credit_card_product_guid, $contentType);
        return $response;
    }

    /**
     * Operation creditCardWithHttpInfo
     *
     * Read a Credit Card Product
     *
     * @param  string $credit_card_product_guid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditCard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreditCardProductResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditCardWithHttpInfo($credit_card_product_guid, string $contentType = self::contentTypes['creditCard'][0])
    {
        $request = $this->creditCardRequest($credit_card_product_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CreditCardProductResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CreditCardProductResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreditCardProductResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation creditCardAsync
     *
     * Read a Credit Card Product
     *
     * @param  string $credit_card_product_guid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditCardAsync($credit_card_product_guid, string $contentType = self::contentTypes['creditCard'][0])
    {
        return $this->creditCardAsyncWithHttpInfo($credit_card_product_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditCardAsyncWithHttpInfo
     *
     * Read a Credit Card Product
     *
     * @param  string $credit_card_product_guid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditCardAsyncWithHttpInfo($credit_card_product_guid, string $contentType = self::contentTypes['creditCard'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CreditCardProductResponse';
        $request = $this->creditCardRequest($credit_card_product_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditCard'
     *
     * @param  string $credit_card_product_guid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function creditCardRequest($credit_card_product_guid, string $contentType = self::contentTypes['creditCard'][0])
    {

        // verify the required parameter 'credit_card_product_guid' is set
        if ($credit_card_product_guid === null || (is_array($credit_card_product_guid) && count($credit_card_product_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_card_product_guid when calling creditCard'
            );
        }


        $resourcePath = '/credit_card_products/{credit_card_product_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_card_product_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'credit_card_product_guid' . '}',
                ObjectSerializer::toPathValue($credit_card_product_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteManagedAccount
     *
     * Delete managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteManagedAccount($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedAccount'][0])
    {
        $this->deleteManagedAccountWithHttpInfo($account_guid, $member_guid, $user_guid, $contentType);
    }

    /**
     * Operation deleteManagedAccountWithHttpInfo
     *
     * Delete managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteManagedAccountWithHttpInfo($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedAccount'][0])
    {
        $request = $this->deleteManagedAccountRequest($account_guid, $member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteManagedAccountAsync
     *
     * Delete managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteManagedAccountAsync($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedAccount'][0])
    {
        return $this->deleteManagedAccountAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteManagedAccountAsyncWithHttpInfo
     *
     * Delete managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteManagedAccountAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedAccount'][0])
    {
        $returnType = '';
        $request = $this->deleteManagedAccountRequest($account_guid, $member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteManagedAccount'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteManagedAccountRequest($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling deleteManagedAccount'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling deleteManagedAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteManagedAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteManagedMember
     *
     * Delete managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteManagedMember($member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedMember'][0])
    {
        $this->deleteManagedMemberWithHttpInfo($member_guid, $user_guid, $contentType);
    }

    /**
     * Operation deleteManagedMemberWithHttpInfo
     *
     * Delete managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteManagedMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedMember'][0])
    {
        $request = $this->deleteManagedMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteManagedMemberAsync
     *
     * Delete managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteManagedMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedMember'][0])
    {
        return $this->deleteManagedMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteManagedMemberAsyncWithHttpInfo
     *
     * Delete managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteManagedMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedMember'][0])
    {
        $returnType = '';
        $request = $this->deleteManagedMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteManagedMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteManagedMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['deleteManagedMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling deleteManagedMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteManagedMember'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteManualAccount
     *
     * Delete manual account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManualAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteManualAccount($account_guid, $user_guid, string $contentType = self::contentTypes['deleteManualAccount'][0])
    {
        $this->deleteManualAccountWithHttpInfo($account_guid, $user_guid, $contentType);
    }

    /**
     * Operation deleteManualAccountWithHttpInfo
     *
     * Delete manual account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManualAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteManualAccountWithHttpInfo($account_guid, $user_guid, string $contentType = self::contentTypes['deleteManualAccount'][0])
    {
        $request = $this->deleteManualAccountRequest($account_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteManualAccountAsync
     *
     * Delete manual account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManualAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteManualAccountAsync($account_guid, $user_guid, string $contentType = self::contentTypes['deleteManualAccount'][0])
    {
        return $this->deleteManualAccountAsyncWithHttpInfo($account_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteManualAccountAsyncWithHttpInfo
     *
     * Delete manual account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManualAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteManualAccountAsyncWithHttpInfo($account_guid, $user_guid, string $contentType = self::contentTypes['deleteManualAccount'][0])
    {
        $returnType = '';
        $request = $this->deleteManualAccountRequest($account_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteManualAccount'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteManualAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteManualAccountRequest($account_guid, $user_guid, string $contentType = self::contentTypes['deleteManualAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling deleteManualAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteManualAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMember
     *
     * Delete member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMember($member_guid, $user_guid, string $contentType = self::contentTypes['deleteMember'][0])
    {
        $this->deleteMemberWithHttpInfo($member_guid, $user_guid, $contentType);
    }

    /**
     * Operation deleteMemberWithHttpInfo
     *
     * Delete member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['deleteMember'][0])
    {
        $request = $this->deleteMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteMemberAsync
     *
     * Delete member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['deleteMember'][0])
    {
        return $this->deleteMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMemberAsyncWithHttpInfo
     *
     * Delete member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['deleteMember'][0])
    {
        $returnType = '';
        $request = $this->deleteMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['deleteMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling deleteMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTag
     *
     * Delete tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTag($tag_guid, $user_guid, string $contentType = self::contentTypes['deleteTag'][0])
    {
        $this->deleteTagWithHttpInfo($tag_guid, $user_guid, $contentType);
    }

    /**
     * Operation deleteTagWithHttpInfo
     *
     * Delete tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTagWithHttpInfo($tag_guid, $user_guid, string $contentType = self::contentTypes['deleteTag'][0])
    {
        $request = $this->deleteTagRequest($tag_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTagAsync
     *
     * Delete tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTagAsync($tag_guid, $user_guid, string $contentType = self::contentTypes['deleteTag'][0])
    {
        return $this->deleteTagAsyncWithHttpInfo($tag_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTagAsyncWithHttpInfo
     *
     * Delete tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTagAsyncWithHttpInfo($tag_guid, $user_guid, string $contentType = self::contentTypes['deleteTag'][0])
    {
        $returnType = '';
        $request = $this->deleteTagRequest($tag_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTag'
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTagRequest($tag_guid, $user_guid, string $contentType = self::contentTypes['deleteTag'][0])
    {

        // verify the required parameter 'tag_guid' is set
        if ($tag_guid === null || (is_array($tag_guid) && count($tag_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_guid when calling deleteTag'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteTag'
            );
        }


        $resourcePath = '/users/{user_guid}/tags/{tag_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tag_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tag_guid' . '}',
                ObjectSerializer::toPathValue($tag_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTagging
     *
     * Delete tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTagging($tagging_guid, $user_guid, string $contentType = self::contentTypes['deleteTagging'][0])
    {
        $this->deleteTaggingWithHttpInfo($tagging_guid, $user_guid, $contentType);
    }

    /**
     * Operation deleteTaggingWithHttpInfo
     *
     * Delete tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaggingWithHttpInfo($tagging_guid, $user_guid, string $contentType = self::contentTypes['deleteTagging'][0])
    {
        $request = $this->deleteTaggingRequest($tagging_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTaggingAsync
     *
     * Delete tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaggingAsync($tagging_guid, $user_guid, string $contentType = self::contentTypes['deleteTagging'][0])
    {
        return $this->deleteTaggingAsyncWithHttpInfo($tagging_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaggingAsyncWithHttpInfo
     *
     * Delete tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaggingAsyncWithHttpInfo($tagging_guid, $user_guid, string $contentType = self::contentTypes['deleteTagging'][0])
    {
        $returnType = '';
        $request = $this->deleteTaggingRequest($tagging_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTagging'
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTaggingRequest($tagging_guid, $user_guid, string $contentType = self::contentTypes['deleteTagging'][0])
    {

        // verify the required parameter 'tagging_guid' is set
        if ($tagging_guid === null || (is_array($tagging_guid) && count($tagging_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagging_guid when calling deleteTagging'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteTagging'
            );
        }


        $resourcePath = '/users/{user_guid}/taggings/{tagging_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tagging_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tagging_guid' . '}',
                ObjectSerializer::toPathValue($tagging_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUser
     *
     * Delete user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteUser($user_guid, string $contentType = self::contentTypes['deleteUser'][0])
    {
        $this->deleteUserWithHttpInfo($user_guid, $contentType);
    }

    /**
     * Operation deleteUserWithHttpInfo
     *
     * Delete user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserWithHttpInfo($user_guid, string $contentType = self::contentTypes['deleteUser'][0])
    {
        $request = $this->deleteUserRequest($user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteUserAsync
     *
     * Delete user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsync($user_guid, string $contentType = self::contentTypes['deleteUser'][0])
    {
        return $this->deleteUserAsyncWithHttpInfo($user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserAsyncWithHttpInfo
     *
     * Delete user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsyncWithHttpInfo($user_guid, string $contentType = self::contentTypes['deleteUser'][0])
    {
        $returnType = '';
        $request = $this->deleteUserRequest($user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUser'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteUserRequest($user_guid, string $contentType = self::contentTypes['deleteUser'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling deleteUser'
            );
        }


        $resourcePath = '/users/{user_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deprecatedRequestPaymentProcessorAuthorizationCode
     *
     * (Deprecated) Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeRequestBody $payment_processor_authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeResponseBody
     */
    public function deprecatedRequestPaymentProcessorAuthorizationCode($payment_processor_authorization_code_request_body, string $contentType = self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'][0])
    {
        list($response) = $this->deprecatedRequestPaymentProcessorAuthorizationCodeWithHttpInfo($payment_processor_authorization_code_request_body, $contentType);
        return $response;
    }

    /**
     * Operation deprecatedRequestPaymentProcessorAuthorizationCodeWithHttpInfo
     *
     * (Deprecated) Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeRequestBody $payment_processor_authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function deprecatedRequestPaymentProcessorAuthorizationCodeWithHttpInfo($payment_processor_authorization_code_request_body, string $contentType = self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'][0])
    {
        $request = $this->deprecatedRequestPaymentProcessorAuthorizationCodeRequest($payment_processor_authorization_code_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deprecatedRequestPaymentProcessorAuthorizationCodeAsync
     *
     * (Deprecated) Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeRequestBody $payment_processor_authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deprecatedRequestPaymentProcessorAuthorizationCodeAsync($payment_processor_authorization_code_request_body, string $contentType = self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'][0])
    {
        return $this->deprecatedRequestPaymentProcessorAuthorizationCodeAsyncWithHttpInfo($payment_processor_authorization_code_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deprecatedRequestPaymentProcessorAuthorizationCodeAsyncWithHttpInfo
     *
     * (Deprecated) Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeRequestBody $payment_processor_authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deprecatedRequestPaymentProcessorAuthorizationCodeAsyncWithHttpInfo($payment_processor_authorization_code_request_body, string $contentType = self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeResponseBody';
        $request = $this->deprecatedRequestPaymentProcessorAuthorizationCodeRequest($payment_processor_authorization_code_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deprecatedRequestPaymentProcessorAuthorizationCode'
     *
     * @param  \OpenAPI\Client\Model\PaymentProcessorAuthorizationCodeRequestBody $payment_processor_authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deprecatedRequestPaymentProcessorAuthorizationCodeRequest($payment_processor_authorization_code_request_body, string $contentType = self::contentTypes['deprecatedRequestPaymentProcessorAuthorizationCode'][0])
    {

        // verify the required parameter 'payment_processor_authorization_code_request_body' is set
        if ($payment_processor_authorization_code_request_body === null || (is_array($payment_processor_authorization_code_request_body) && count($payment_processor_authorization_code_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_processor_authorization_code_request_body when calling deprecatedRequestPaymentProcessorAuthorizationCode'
            );
        }


        $resourcePath = '/payment_processor_authorization_code';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_processor_authorization_code_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_processor_authorization_code_request_body));
            } else {
                $httpBody = $payment_processor_authorization_code_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadStatementPDF
     *
     * Download statement pdf
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadStatementPDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadStatementPDF($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['downloadStatementPDF'][0])
    {
        list($response) = $this->downloadStatementPDFWithHttpInfo($member_guid, $statement_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation downloadStatementPDFWithHttpInfo
     *
     * Download statement pdf
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadStatementPDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadStatementPDFWithHttpInfo($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['downloadStatementPDF'][0])
    {
        $request = $this->downloadStatementPDFRequest($member_guid, $statement_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation downloadStatementPDFAsync
     *
     * Download statement pdf
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadStatementPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadStatementPDFAsync($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['downloadStatementPDF'][0])
    {
        return $this->downloadStatementPDFAsyncWithHttpInfo($member_guid, $statement_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadStatementPDFAsyncWithHttpInfo
     *
     * Download statement pdf
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadStatementPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadStatementPDFAsyncWithHttpInfo($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['downloadStatementPDF'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadStatementPDFRequest($member_guid, $statement_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadStatementPDF'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadStatementPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadStatementPDFRequest($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['downloadStatementPDF'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling downloadStatementPDF'
            );
        }

        // verify the required parameter 'statement_guid' is set
        if ($statement_guid === null || (is_array($statement_guid) && count($statement_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $statement_guid when calling downloadStatementPDF'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling downloadStatementPDF'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/statements/{statement_guid}.pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($statement_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'statement_guid' . '}',
                ObjectSerializer::toPathValue($statement_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+pdf', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadTaxDocument
     *
     * Download a Tax Document PDF
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadTaxDocument($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['downloadTaxDocument'][0])
    {
        list($response) = $this->downloadTaxDocumentWithHttpInfo($tax_document_guid, $member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation downloadTaxDocumentWithHttpInfo
     *
     * Download a Tax Document PDF
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadTaxDocumentWithHttpInfo($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['downloadTaxDocument'][0])
    {
        $request = $this->downloadTaxDocumentRequest($tax_document_guid, $member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation downloadTaxDocumentAsync
     *
     * Download a Tax Document PDF
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadTaxDocumentAsync($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['downloadTaxDocument'][0])
    {
        return $this->downloadTaxDocumentAsyncWithHttpInfo($tax_document_guid, $member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadTaxDocumentAsyncWithHttpInfo
     *
     * Download a Tax Document PDF
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadTaxDocumentAsyncWithHttpInfo($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['downloadTaxDocument'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadTaxDocumentRequest($tax_document_guid, $member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadTaxDocument'
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadTaxDocumentRequest($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['downloadTaxDocument'][0])
    {

        // verify the required parameter 'tax_document_guid' is set
        if ($tax_document_guid === null || (is_array($tax_document_guid) && count($tax_document_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_document_guid when calling downloadTaxDocument'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling downloadTaxDocument'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling downloadTaxDocument'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/tax_documents/{tax_document_guid}.pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tax_document_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tax_document_guid' . '}',
                ObjectSerializer::toPathValue($tax_document_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+pdf', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extendHistory
     *
     * Extend history
     *
     * @param  string $member_guid The unique identifier for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique identifier for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function extendHistory($member_guid, $user_guid, string $contentType = self::contentTypes['extendHistory'][0])
    {
        list($response) = $this->extendHistoryWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation extendHistoryWithHttpInfo
     *
     * Extend history
     *
     * @param  string $member_guid The unique identifier for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique identifier for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function extendHistoryWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['extendHistory'][0])
    {
        $request = $this->extendHistoryRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation extendHistoryAsync
     *
     * Extend history
     *
     * @param  string $member_guid The unique identifier for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique identifier for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extendHistoryAsync($member_guid, $user_guid, string $contentType = self::contentTypes['extendHistory'][0])
    {
        return $this->extendHistoryAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extendHistoryAsyncWithHttpInfo
     *
     * Extend history
     *
     * @param  string $member_guid The unique identifier for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique identifier for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extendHistoryAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['extendHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->extendHistoryRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extendHistory'
     *
     * @param  string $member_guid The unique identifier for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique identifier for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extendHistoryRequest($member_guid, $user_guid, string $contentType = self::contentTypes['extendHistory'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling extendHistory'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling extendHistory'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/extend_history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchRewards
     *
     * Fetch Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchRewards'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function fetchRewards($user_guid, $member_guid, string $contentType = self::contentTypes['fetchRewards'][0])
    {
        list($response) = $this->fetchRewardsWithHttpInfo($user_guid, $member_guid, $contentType);
        return $response;
    }

    /**
     * Operation fetchRewardsWithHttpInfo
     *
     * Fetch Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchRewards'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchRewardsWithHttpInfo($user_guid, $member_guid, string $contentType = self::contentTypes['fetchRewards'][0])
    {
        $request = $this->fetchRewardsRequest($user_guid, $member_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation fetchRewardsAsync
     *
     * Fetch Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchRewardsAsync($user_guid, $member_guid, string $contentType = self::contentTypes['fetchRewards'][0])
    {
        return $this->fetchRewardsAsyncWithHttpInfo($user_guid, $member_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchRewardsAsyncWithHttpInfo
     *
     * Fetch Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchRewardsAsyncWithHttpInfo($user_guid, $member_guid, string $contentType = self::contentTypes['fetchRewards'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->fetchRewardsRequest($user_guid, $member_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchRewards'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fetchRewardsRequest($user_guid, $member_guid, string $contentType = self::contentTypes['fetchRewards'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling fetchRewards'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling fetchRewards'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/fetch_rewards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchStatements
     *
     * Fetch statements
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchStatements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function fetchStatements($member_guid, $user_guid, string $contentType = self::contentTypes['fetchStatements'][0])
    {
        list($response) = $this->fetchStatementsWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation fetchStatementsWithHttpInfo
     *
     * Fetch statements
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchStatements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchStatementsWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['fetchStatements'][0])
    {
        $request = $this->fetchStatementsRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation fetchStatementsAsync
     *
     * Fetch statements
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchStatements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchStatementsAsync($member_guid, $user_guid, string $contentType = self::contentTypes['fetchStatements'][0])
    {
        return $this->fetchStatementsAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchStatementsAsyncWithHttpInfo
     *
     * Fetch statements
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchStatements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchStatementsAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['fetchStatements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->fetchStatementsRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchStatements'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchStatements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fetchStatementsRequest($member_guid, $user_guid, string $contentType = self::contentTypes['fetchStatements'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling fetchStatements'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling fetchStatements'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/fetch_statements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchTaxDocuments
     *
     * Fetch Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function fetchTaxDocuments($member_guid, $user_guid, string $contentType = self::contentTypes['fetchTaxDocuments'][0])
    {
        list($response) = $this->fetchTaxDocumentsWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation fetchTaxDocumentsWithHttpInfo
     *
     * Fetch Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchTaxDocumentsWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['fetchTaxDocuments'][0])
    {
        $request = $this->fetchTaxDocumentsRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation fetchTaxDocumentsAsync
     *
     * Fetch Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchTaxDocumentsAsync($member_guid, $user_guid, string $contentType = self::contentTypes['fetchTaxDocuments'][0])
    {
        return $this->fetchTaxDocumentsAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchTaxDocumentsAsyncWithHttpInfo
     *
     * Fetch Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchTaxDocumentsAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['fetchTaxDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->fetchTaxDocumentsRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchTaxDocuments'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fetchTaxDocumentsRequest($member_guid, $user_guid, string $contentType = self::contentTypes['fetchTaxDocuments'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling fetchTaxDocuments'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling fetchTaxDocuments'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/fetch_tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation identifyMember
     *
     * Identify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['identifyMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function identifyMember($member_guid, $user_guid, string $contentType = self::contentTypes['identifyMember'][0])
    {
        list($response) = $this->identifyMemberWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation identifyMemberWithHttpInfo
     *
     * Identify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['identifyMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function identifyMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['identifyMember'][0])
    {
        $request = $this->identifyMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation identifyMemberAsync
     *
     * Identify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['identifyMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function identifyMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['identifyMember'][0])
    {
        return $this->identifyMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation identifyMemberAsyncWithHttpInfo
     *
     * Identify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['identifyMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function identifyMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['identifyMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->identifyMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'identifyMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['identifyMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function identifyMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['identifyMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling identifyMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling identifyMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/identify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAccountNumbersByAccount
     *
     * List account numbers by account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountNumbersResponseBody
     */
    public function listAccountNumbersByAccount($account_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByAccount'][0])
    {
        list($response) = $this->listAccountNumbersByAccountWithHttpInfo($account_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listAccountNumbersByAccountWithHttpInfo
     *
     * List account numbers by account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountNumbersResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAccountNumbersByAccountWithHttpInfo($account_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByAccount'][0])
    {
        $request = $this->listAccountNumbersByAccountRequest($account_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountNumbersResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountNumbersResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountNumbersResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listAccountNumbersByAccountAsync
     *
     * List account numbers by account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountNumbersByAccountAsync($account_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByAccount'][0])
    {
        return $this->listAccountNumbersByAccountAsyncWithHttpInfo($account_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAccountNumbersByAccountAsyncWithHttpInfo
     *
     * List account numbers by account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountNumbersByAccountAsyncWithHttpInfo($account_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountNumbersResponseBody';
        $request = $this->listAccountNumbersByAccountRequest($account_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAccountNumbersByAccount'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAccountNumbersByAccountRequest($account_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling listAccountNumbersByAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listAccountNumbersByAccount'
            );
        }




        $resourcePath = '/users/{user_guid}/accounts/{account_guid}/account_numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAccountNumbersByMember
     *
     * List account numbers by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountNumbersResponseBody
     */
    public function listAccountNumbersByMember($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByMember'][0])
    {
        list($response) = $this->listAccountNumbersByMemberWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listAccountNumbersByMemberWithHttpInfo
     *
     * List account numbers by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountNumbersResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAccountNumbersByMemberWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByMember'][0])
    {
        $request = $this->listAccountNumbersByMemberRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountNumbersResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountNumbersResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountNumbersResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listAccountNumbersByMemberAsync
     *
     * List account numbers by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountNumbersByMemberAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByMember'][0])
    {
        return $this->listAccountNumbersByMemberAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAccountNumbersByMemberAsyncWithHttpInfo
     *
     * List account numbers by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountNumbersByMemberAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountNumbersResponseBody';
        $request = $this->listAccountNumbersByMemberRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAccountNumbersByMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountNumbersByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAccountNumbersByMemberRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountNumbersByMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listAccountNumbersByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listAccountNumbersByMember'
            );
        }




        $resourcePath = '/users/{user_guid}/members/{member_guid}/account_numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAccountOwnersByMember
     *
     * List account owners by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountOwnersByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountOwnersResponseBody
     */
    public function listAccountOwnersByMember($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountOwnersByMember'][0])
    {
        list($response) = $this->listAccountOwnersByMemberWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listAccountOwnersByMemberWithHttpInfo
     *
     * List account owners by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountOwnersByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountOwnersResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAccountOwnersByMemberWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountOwnersByMember'][0])
    {
        $request = $this->listAccountOwnersByMemberRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountOwnersResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountOwnersResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountOwnersResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listAccountOwnersByMemberAsync
     *
     * List account owners by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountOwnersByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountOwnersByMemberAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountOwnersByMember'][0])
    {
        return $this->listAccountOwnersByMemberAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAccountOwnersByMemberAsyncWithHttpInfo
     *
     * List account owners by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountOwnersByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountOwnersByMemberAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountOwnersByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountOwnersResponseBody';
        $request = $this->listAccountOwnersByMemberRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAccountOwnersByMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAccountOwnersByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAccountOwnersByMemberRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listAccountOwnersByMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listAccountOwnersByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listAccountOwnersByMember'
            );
        }




        $resourcePath = '/users/{user_guid}/members/{member_guid}/account_owners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategories
     *
     * List categories
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoriesResponseBody
     */
    public function listCategories($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listCategories'][0])
    {
        list($response) = $this->listCategoriesWithHttpInfo($user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listCategoriesWithHttpInfo
     *
     * List categories
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoriesResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoriesWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listCategories'][0])
    {
        $request = $this->listCategoriesRequest($user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoriesResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoriesResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoriesResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCategoriesAsync
     *
     * List categories
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoriesAsync($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listCategories'][0])
    {
        return $this->listCategoriesAsyncWithHttpInfo($user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoriesAsyncWithHttpInfo
     *
     * List categories
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoriesAsyncWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listCategories'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoriesResponseBody';
        $request = $this->listCategoriesRequest($user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategories'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCategoriesRequest($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listCategories'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listCategories'
            );
        }




        $resourcePath = '/users/{user_guid}/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDefaultCategories
     *
     * List default categories
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoriesResponseBody
     */
    public function listDefaultCategories($page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategories'][0])
    {
        list($response) = $this->listDefaultCategoriesWithHttpInfo($page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listDefaultCategoriesWithHttpInfo
     *
     * List default categories
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoriesResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDefaultCategoriesWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategories'][0])
    {
        $request = $this->listDefaultCategoriesRequest($page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoriesResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoriesResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoriesResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listDefaultCategoriesAsync
     *
     * List default categories
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDefaultCategoriesAsync($page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategories'][0])
    {
        return $this->listDefaultCategoriesAsyncWithHttpInfo($page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDefaultCategoriesAsyncWithHttpInfo
     *
     * List default categories
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDefaultCategoriesAsyncWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategories'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoriesResponseBody';
        $request = $this->listDefaultCategoriesRequest($page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDefaultCategories'
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDefaultCategoriesRequest($page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategories'][0])
    {




        $resourcePath = '/categories/default';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDefaultCategoriesByUser
     *
     * List default categories by user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategoriesByUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoriesResponseBody
     */
    public function listDefaultCategoriesByUser($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategoriesByUser'][0])
    {
        list($response) = $this->listDefaultCategoriesByUserWithHttpInfo($user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listDefaultCategoriesByUserWithHttpInfo
     *
     * List default categories by user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategoriesByUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoriesResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDefaultCategoriesByUserWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategoriesByUser'][0])
    {
        $request = $this->listDefaultCategoriesByUserRequest($user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoriesResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoriesResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoriesResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listDefaultCategoriesByUserAsync
     *
     * List default categories by user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategoriesByUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDefaultCategoriesByUserAsync($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategoriesByUser'][0])
    {
        return $this->listDefaultCategoriesByUserAsyncWithHttpInfo($user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDefaultCategoriesByUserAsyncWithHttpInfo
     *
     * List default categories by user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategoriesByUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDefaultCategoriesByUserAsyncWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategoriesByUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoriesResponseBody';
        $request = $this->listDefaultCategoriesByUserRequest($user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDefaultCategoriesByUser'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDefaultCategoriesByUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDefaultCategoriesByUserRequest($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listDefaultCategoriesByUser'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listDefaultCategoriesByUser'
            );
        }




        $resourcePath = '/users/{user_guid}/categories/default';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFavoriteInstitutions
     *
     * List favorite institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFavoriteInstitutions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InstitutionsResponseBody
     */
    public function listFavoriteInstitutions($page = null, $records_per_page = null, string $contentType = self::contentTypes['listFavoriteInstitutions'][0])
    {
        list($response) = $this->listFavoriteInstitutionsWithHttpInfo($page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listFavoriteInstitutionsWithHttpInfo
     *
     * List favorite institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFavoriteInstitutions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InstitutionsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFavoriteInstitutionsWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listFavoriteInstitutions'][0])
    {
        $request = $this->listFavoriteInstitutionsRequest($page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InstitutionsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InstitutionsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InstitutionsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listFavoriteInstitutionsAsync
     *
     * List favorite institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFavoriteInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFavoriteInstitutionsAsync($page = null, $records_per_page = null, string $contentType = self::contentTypes['listFavoriteInstitutions'][0])
    {
        return $this->listFavoriteInstitutionsAsyncWithHttpInfo($page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFavoriteInstitutionsAsyncWithHttpInfo
     *
     * List favorite institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFavoriteInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFavoriteInstitutionsAsyncWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listFavoriteInstitutions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InstitutionsResponseBody';
        $request = $this->listFavoriteInstitutionsRequest($page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFavoriteInstitutions'
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFavoriteInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listFavoriteInstitutionsRequest($page = null, $records_per_page = null, string $contentType = self::contentTypes['listFavoriteInstitutions'][0])
    {




        $resourcePath = '/institutions/favorites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listHoldings
     *
     * List holdings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HoldingsResponseBody
     */
    public function listHoldings($user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldings'][0])
    {
        list($response) = $this->listHoldingsWithHttpInfo($user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);
        return $response;
    }

    /**
     * Operation listHoldingsWithHttpInfo
     *
     * List holdings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HoldingsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listHoldingsWithHttpInfo($user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldings'][0])
    {
        $request = $this->listHoldingsRequest($user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HoldingsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HoldingsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HoldingsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listHoldingsAsync
     *
     * List holdings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHoldingsAsync($user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldings'][0])
    {
        return $this->listHoldingsAsyncWithHttpInfo($user_guid, $from_date, $page, $records_per_page, $to_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listHoldingsAsyncWithHttpInfo
     *
     * List holdings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHoldingsAsyncWithHttpInfo($user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HoldingsResponseBody';
        $request = $this->listHoldingsRequest($user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listHoldings'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listHoldingsRequest($user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldings'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listHoldings'
            );
        }






        $resourcePath = '/users/{user_guid}/holdings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from_date,
            'from_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_date,
            'to_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listHoldingsByAccount
     *
     * List holdings by account
     *
     * @param  string $account_guid The unique id for the &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for the &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HoldingsResponseBody
     */
    public function listHoldingsByAccount($account_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByAccount'][0])
    {
        list($response) = $this->listHoldingsByAccountWithHttpInfo($account_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);
        return $response;
    }

    /**
     * Operation listHoldingsByAccountWithHttpInfo
     *
     * List holdings by account
     *
     * @param  string $account_guid The unique id for the &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for the &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HoldingsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listHoldingsByAccountWithHttpInfo($account_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByAccount'][0])
    {
        $request = $this->listHoldingsByAccountRequest($account_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HoldingsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HoldingsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HoldingsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listHoldingsByAccountAsync
     *
     * List holdings by account
     *
     * @param  string $account_guid The unique id for the &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for the &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHoldingsByAccountAsync($account_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByAccount'][0])
    {
        return $this->listHoldingsByAccountAsyncWithHttpInfo($account_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listHoldingsByAccountAsyncWithHttpInfo
     *
     * List holdings by account
     *
     * @param  string $account_guid The unique id for the &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for the &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHoldingsByAccountAsyncWithHttpInfo($account_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HoldingsResponseBody';
        $request = $this->listHoldingsByAccountRequest($account_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listHoldingsByAccount'
     *
     * @param  string $account_guid The unique id for the &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for the &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listHoldingsByAccountRequest($account_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling listHoldingsByAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listHoldingsByAccount'
            );
        }






        $resourcePath = '/users/{user_guid}/accounts/{account_guid}/holdings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from_date,
            'from_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_date,
            'to_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listHoldingsByMember
     *
     * List holdings by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HoldingsResponseBody
     */
    public function listHoldingsByMember($member_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByMember'][0])
    {
        list($response) = $this->listHoldingsByMemberWithHttpInfo($member_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);
        return $response;
    }

    /**
     * Operation listHoldingsByMemberWithHttpInfo
     *
     * List holdings by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HoldingsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listHoldingsByMemberWithHttpInfo($member_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByMember'][0])
    {
        $request = $this->listHoldingsByMemberRequest($member_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HoldingsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HoldingsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HoldingsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listHoldingsByMemberAsync
     *
     * List holdings by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHoldingsByMemberAsync($member_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByMember'][0])
    {
        return $this->listHoldingsByMemberAsyncWithHttpInfo($member_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listHoldingsByMemberAsyncWithHttpInfo
     *
     * List holdings by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHoldingsByMemberAsyncWithHttpInfo($member_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HoldingsResponseBody';
        $request = $this->listHoldingsByMemberRequest($member_guid, $user_guid, $from_date, $page, $records_per_page, $to_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listHoldingsByMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $from_date Filter holdings from this date. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $to_date Filter holdings to this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHoldingsByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listHoldingsByMemberRequest($member_guid, $user_guid, $from_date = null, $page = null, $records_per_page = null, $to_date = null, string $contentType = self::contentTypes['listHoldingsByMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listHoldingsByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listHoldingsByMember'
            );
        }






        $resourcePath = '/users/{user_guid}/members/{member_guid}/holdings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from_date,
            'from_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_date,
            'to_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInstitutionCredentials
     *
     * List institution credentials
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutionCredentials'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CredentialsResponseBody
     */
    public function listInstitutionCredentials($institution_code, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listInstitutionCredentials'][0])
    {
        list($response) = $this->listInstitutionCredentialsWithHttpInfo($institution_code, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listInstitutionCredentialsWithHttpInfo
     *
     * List institution credentials
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutionCredentials'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CredentialsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInstitutionCredentialsWithHttpInfo($institution_code, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listInstitutionCredentials'][0])
    {
        $request = $this->listInstitutionCredentialsRequest($institution_code, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CredentialsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CredentialsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CredentialsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listInstitutionCredentialsAsync
     *
     * List institution credentials
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutionCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInstitutionCredentialsAsync($institution_code, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listInstitutionCredentials'][0])
    {
        return $this->listInstitutionCredentialsAsyncWithHttpInfo($institution_code, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInstitutionCredentialsAsyncWithHttpInfo
     *
     * List institution credentials
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutionCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInstitutionCredentialsAsyncWithHttpInfo($institution_code, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listInstitutionCredentials'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CredentialsResponseBody';
        $request = $this->listInstitutionCredentialsRequest($institution_code, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInstitutionCredentials'
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutionCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInstitutionCredentialsRequest($institution_code, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listInstitutionCredentials'][0])
    {

        // verify the required parameter 'institution_code' is set
        if ($institution_code === null || (is_array($institution_code) && count($institution_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $institution_code when calling listInstitutionCredentials'
            );
        }




        $resourcePath = '/institutions/{institution_code}/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($institution_code !== null) {
            $resourcePath = str_replace(
                '{' . 'institution_code' . '}',
                ObjectSerializer::toPathValue($institution_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInstitutions
     *
     * List institutions
     *
     * @param  string|null $name This will list only institutions in which the appended string appears. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  bool|null $supports_account_identification Filter only institutions which support account identification. (optional)
     * @param  bool|null $supports_account_statement Filter only institutions which support account statements. (optional)
     * @param  bool|null $supports_account_verification Filter only institutions which support account verification. (optional)
     * @param  bool|null $supports_transaction_history Filter only institutions which support extended transaction history. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InstitutionsResponseBody
     */
    public function listInstitutions($name = null, $page = null, $records_per_page = null, $supports_account_identification = null, $supports_account_statement = null, $supports_account_verification = null, $supports_transaction_history = null, string $contentType = self::contentTypes['listInstitutions'][0])
    {
        list($response) = $this->listInstitutionsWithHttpInfo($name, $page, $records_per_page, $supports_account_identification, $supports_account_statement, $supports_account_verification, $supports_transaction_history, $contentType);
        return $response;
    }

    /**
     * Operation listInstitutionsWithHttpInfo
     *
     * List institutions
     *
     * @param  string|null $name This will list only institutions in which the appended string appears. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  bool|null $supports_account_identification Filter only institutions which support account identification. (optional)
     * @param  bool|null $supports_account_statement Filter only institutions which support account statements. (optional)
     * @param  bool|null $supports_account_verification Filter only institutions which support account verification. (optional)
     * @param  bool|null $supports_transaction_history Filter only institutions which support extended transaction history. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InstitutionsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInstitutionsWithHttpInfo($name = null, $page = null, $records_per_page = null, $supports_account_identification = null, $supports_account_statement = null, $supports_account_verification = null, $supports_transaction_history = null, string $contentType = self::contentTypes['listInstitutions'][0])
    {
        $request = $this->listInstitutionsRequest($name, $page, $records_per_page, $supports_account_identification, $supports_account_statement, $supports_account_verification, $supports_transaction_history, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InstitutionsResponseBody',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InstitutionsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InstitutionsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listInstitutionsAsync
     *
     * List institutions
     *
     * @param  string|null $name This will list only institutions in which the appended string appears. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  bool|null $supports_account_identification Filter only institutions which support account identification. (optional)
     * @param  bool|null $supports_account_statement Filter only institutions which support account statements. (optional)
     * @param  bool|null $supports_account_verification Filter only institutions which support account verification. (optional)
     * @param  bool|null $supports_transaction_history Filter only institutions which support extended transaction history. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInstitutionsAsync($name = null, $page = null, $records_per_page = null, $supports_account_identification = null, $supports_account_statement = null, $supports_account_verification = null, $supports_transaction_history = null, string $contentType = self::contentTypes['listInstitutions'][0])
    {
        return $this->listInstitutionsAsyncWithHttpInfo($name, $page, $records_per_page, $supports_account_identification, $supports_account_statement, $supports_account_verification, $supports_transaction_history, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInstitutionsAsyncWithHttpInfo
     *
     * List institutions
     *
     * @param  string|null $name This will list only institutions in which the appended string appears. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  bool|null $supports_account_identification Filter only institutions which support account identification. (optional)
     * @param  bool|null $supports_account_statement Filter only institutions which support account statements. (optional)
     * @param  bool|null $supports_account_verification Filter only institutions which support account verification. (optional)
     * @param  bool|null $supports_transaction_history Filter only institutions which support extended transaction history. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInstitutionsAsyncWithHttpInfo($name = null, $page = null, $records_per_page = null, $supports_account_identification = null, $supports_account_statement = null, $supports_account_verification = null, $supports_transaction_history = null, string $contentType = self::contentTypes['listInstitutions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InstitutionsResponseBody';
        $request = $this->listInstitutionsRequest($name, $page, $records_per_page, $supports_account_identification, $supports_account_statement, $supports_account_verification, $supports_transaction_history, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInstitutions'
     *
     * @param  string|null $name This will list only institutions in which the appended string appears. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  bool|null $supports_account_identification Filter only institutions which support account identification. (optional)
     * @param  bool|null $supports_account_statement Filter only institutions which support account statements. (optional)
     * @param  bool|null $supports_account_verification Filter only institutions which support account verification. (optional)
     * @param  bool|null $supports_transaction_history Filter only institutions which support extended transaction history. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInstitutionsRequest($name = null, $page = null, $records_per_page = null, $supports_account_identification = null, $supports_account_statement = null, $supports_account_verification = null, $supports_transaction_history = null, string $contentType = self::contentTypes['listInstitutions'][0])
    {
        $resourcePath = '/institutions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supports_account_identification,
            'supports_account_identification', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supports_account_statement,
            'supports_account_statement', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supports_account_verification,
            'supports_account_verification', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supports_transaction_history,
            'supports_transaction_history', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listManagedAccounts
     *
     * List managed accounts
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountsResponseBody
     */
    public function listManagedAccounts($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedAccounts'][0])
    {
        list($response) = $this->listManagedAccountsWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listManagedAccountsWithHttpInfo
     *
     * List managed accounts
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listManagedAccountsWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedAccounts'][0])
    {
        $request = $this->listManagedAccountsRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listManagedAccountsAsync
     *
     * List managed accounts
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listManagedAccountsAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedAccounts'][0])
    {
        return $this->listManagedAccountsAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listManagedAccountsAsyncWithHttpInfo
     *
     * List managed accounts
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listManagedAccountsAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedAccounts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountsResponseBody';
        $request = $this->listManagedAccountsRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listManagedAccounts'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listManagedAccountsRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedAccounts'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listManagedAccounts'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listManagedAccounts'
            );
        }




        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listManagedInstitutions
     *
     * List managed institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedInstitutions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InstitutionsResponseBody
     */
    public function listManagedInstitutions($page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedInstitutions'][0])
    {
        list($response) = $this->listManagedInstitutionsWithHttpInfo($page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listManagedInstitutionsWithHttpInfo
     *
     * List managed institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedInstitutions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InstitutionsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listManagedInstitutionsWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedInstitutions'][0])
    {
        $request = $this->listManagedInstitutionsRequest($page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InstitutionsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InstitutionsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InstitutionsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listManagedInstitutionsAsync
     *
     * List managed institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listManagedInstitutionsAsync($page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedInstitutions'][0])
    {
        return $this->listManagedInstitutionsAsyncWithHttpInfo($page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listManagedInstitutionsAsyncWithHttpInfo
     *
     * List managed institutions
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listManagedInstitutionsAsyncWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedInstitutions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InstitutionsResponseBody';
        $request = $this->listManagedInstitutionsRequest($page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listManagedInstitutions'
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedInstitutions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listManagedInstitutionsRequest($page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedInstitutions'][0])
    {




        $resourcePath = '/managed_institutions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listManagedMembers
     *
     * List managed members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedMembers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MembersResponseBody
     */
    public function listManagedMembers($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedMembers'][0])
    {
        list($response) = $this->listManagedMembersWithHttpInfo($user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listManagedMembersWithHttpInfo
     *
     * List managed members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedMembers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MembersResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listManagedMembersWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedMembers'][0])
    {
        $request = $this->listManagedMembersRequest($user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MembersResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MembersResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MembersResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listManagedMembersAsync
     *
     * List managed members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listManagedMembersAsync($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedMembers'][0])
    {
        return $this->listManagedMembersAsyncWithHttpInfo($user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listManagedMembersAsyncWithHttpInfo
     *
     * List managed members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listManagedMembersAsyncWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedMembers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MembersResponseBody';
        $request = $this->listManagedMembersRequest($user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listManagedMembers'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listManagedMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listManagedMembersRequest($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listManagedMembers'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listManagedMembers'
            );
        }




        $resourcePath = '/users/{user_guid}/managed_members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMemberAccounts
     *
     * List accounts by member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountsResponseBody
     */
    public function listMemberAccounts($user_guid, $member_guid, $member_is_managed_by_user = null, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberAccounts'][0])
    {
        list($response) = $this->listMemberAccountsWithHttpInfo($user_guid, $member_guid, $member_is_managed_by_user, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listMemberAccountsWithHttpInfo
     *
     * List accounts by member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMemberAccountsWithHttpInfo($user_guid, $member_guid, $member_is_managed_by_user = null, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberAccounts'][0])
    {
        $request = $this->listMemberAccountsRequest($user_guid, $member_guid, $member_is_managed_by_user, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMemberAccountsAsync
     *
     * List accounts by member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMemberAccountsAsync($user_guid, $member_guid, $member_is_managed_by_user = null, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberAccounts'][0])
    {
        return $this->listMemberAccountsAsyncWithHttpInfo($user_guid, $member_guid, $member_is_managed_by_user, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMemberAccountsAsyncWithHttpInfo
     *
     * List accounts by member
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMemberAccountsAsyncWithHttpInfo($user_guid, $member_guid, $member_is_managed_by_user = null, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberAccounts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountsResponseBody';
        $request = $this->listMemberAccountsRequest($user_guid, $member_guid, $member_is_managed_by_user, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMemberAccounts'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMemberAccountsRequest($user_guid, $member_guid, $member_is_managed_by_user = null, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberAccounts'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listMemberAccounts'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listMemberAccounts'
            );
        }





        $resourcePath = '/users/{user_guid}/members/{member_guid}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $member_is_managed_by_user,
            'member_is_managed_by_user', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMemberChallenges
     *
     * List member challenges
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberChallenges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ChallengesResponseBody
     */
    public function listMemberChallenges($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberChallenges'][0])
    {
        list($response) = $this->listMemberChallengesWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listMemberChallengesWithHttpInfo
     *
     * List member challenges
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberChallenges'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ChallengesResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMemberChallengesWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberChallenges'][0])
    {
        $request = $this->listMemberChallengesRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ChallengesResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ChallengesResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ChallengesResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMemberChallengesAsync
     *
     * List member challenges
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberChallenges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMemberChallengesAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberChallenges'][0])
    {
        return $this->listMemberChallengesAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMemberChallengesAsyncWithHttpInfo
     *
     * List member challenges
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberChallenges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMemberChallengesAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberChallenges'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ChallengesResponseBody';
        $request = $this->listMemberChallengesRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMemberChallenges'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberChallenges'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMemberChallengesRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberChallenges'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listMemberChallenges'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listMemberChallenges'
            );
        }




        $resourcePath = '/users/{user_guid}/members/{member_guid}/challenges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMemberCredentials
     *
     * List member credentials
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberCredentials'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CredentialsResponseBody
     */
    public function listMemberCredentials($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberCredentials'][0])
    {
        list($response) = $this->listMemberCredentialsWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listMemberCredentialsWithHttpInfo
     *
     * List member credentials
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberCredentials'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CredentialsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMemberCredentialsWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberCredentials'][0])
    {
        $request = $this->listMemberCredentialsRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CredentialsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CredentialsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CredentialsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMemberCredentialsAsync
     *
     * List member credentials
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMemberCredentialsAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberCredentials'][0])
    {
        return $this->listMemberCredentialsAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMemberCredentialsAsyncWithHttpInfo
     *
     * List member credentials
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMemberCredentialsAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberCredentials'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CredentialsResponseBody';
        $request = $this->listMemberCredentialsRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMemberCredentials'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMemberCredentials'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMemberCredentialsRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMemberCredentials'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listMemberCredentials'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listMemberCredentials'
            );
        }




        $resourcePath = '/users/{user_guid}/members/{member_guid}/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMembers
     *
     * List members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MembersResponseBody
     */
    public function listMembers($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        list($response) = $this->listMembersWithHttpInfo($user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listMembersWithHttpInfo
     *
     * List members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MembersResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMembersWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        $request = $this->listMembersRequest($user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MembersResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MembersResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MembersResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMembersAsync
     *
     * List members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsync($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        return $this->listMembersAsyncWithHttpInfo($user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMembersAsyncWithHttpInfo
     *
     * List members
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsyncWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MembersResponseBody';
        $request = $this->listMembersRequest($user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMembers'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMembersRequest($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listMembers'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listMembers'
            );
        }




        $resourcePath = '/users/{user_guid}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMerchants
     *
     * List merchants
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchants'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MerchantsResponseBody
     */
    public function listMerchants($page = null, $records_per_page = null, string $contentType = self::contentTypes['listMerchants'][0])
    {
        list($response) = $this->listMerchantsWithHttpInfo($page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listMerchantsWithHttpInfo
     *
     * List merchants
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchants'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MerchantsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMerchantsWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listMerchants'][0])
    {
        $request = $this->listMerchantsRequest($page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MerchantsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MerchantsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MerchantsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMerchantsAsync
     *
     * List merchants
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMerchantsAsync($page = null, $records_per_page = null, string $contentType = self::contentTypes['listMerchants'][0])
    {
        return $this->listMerchantsAsyncWithHttpInfo($page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMerchantsAsyncWithHttpInfo
     *
     * List merchants
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMerchantsAsyncWithHttpInfo($page = null, $records_per_page = null, string $contentType = self::contentTypes['listMerchants'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MerchantsResponseBody';
        $request = $this->listMerchantsRequest($page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMerchants'
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMerchantsRequest($page = null, $records_per_page = null, string $contentType = self::contentTypes['listMerchants'][0])
    {




        $resourcePath = '/merchants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRewards
     *
     * List Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRewards'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RewardsResponseBody
     */
    public function listRewards($user_guid, $member_guid, string $contentType = self::contentTypes['listRewards'][0])
    {
        list($response) = $this->listRewardsWithHttpInfo($user_guid, $member_guid, $contentType);
        return $response;
    }

    /**
     * Operation listRewardsWithHttpInfo
     *
     * List Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRewards'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RewardsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRewardsWithHttpInfo($user_guid, $member_guid, string $contentType = self::contentTypes['listRewards'][0])
    {
        $request = $this->listRewardsRequest($user_guid, $member_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RewardsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RewardsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RewardsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listRewardsAsync
     *
     * List Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRewardsAsync($user_guid, $member_guid, string $contentType = self::contentTypes['listRewards'][0])
    {
        return $this->listRewardsAsyncWithHttpInfo($user_guid, $member_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRewardsAsyncWithHttpInfo
     *
     * List Rewards
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRewardsAsyncWithHttpInfo($user_guid, $member_guid, string $contentType = self::contentTypes['listRewards'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RewardsResponseBody';
        $request = $this->listRewardsRequest($user_guid, $member_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRewards'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listRewardsRequest($user_guid, $member_guid, string $contentType = self::contentTypes['listRewards'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listRewards'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listRewards'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/rewards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStatementsByMember
     *
     * List statements by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStatementsByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StatementsResponseBody
     */
    public function listStatementsByMember($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listStatementsByMember'][0])
    {
        list($response) = $this->listStatementsByMemberWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listStatementsByMemberWithHttpInfo
     *
     * List statements by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStatementsByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StatementsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listStatementsByMemberWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listStatementsByMember'][0])
    {
        $request = $this->listStatementsByMemberRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StatementsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StatementsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StatementsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listStatementsByMemberAsync
     *
     * List statements by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStatementsByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStatementsByMemberAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listStatementsByMember'][0])
    {
        return $this->listStatementsByMemberAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStatementsByMemberAsyncWithHttpInfo
     *
     * List statements by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStatementsByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStatementsByMemberAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listStatementsByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StatementsResponseBody';
        $request = $this->listStatementsByMemberRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStatementsByMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStatementsByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listStatementsByMemberRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listStatementsByMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listStatementsByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listStatementsByMember'
            );
        }




        $resourcePath = '/users/{user_guid}/members/{member_guid}/statements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTaggings
     *
     * List taggings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaggings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaggingsResponseBody
     */
    public function listTaggings($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaggings'][0])
    {
        list($response) = $this->listTaggingsWithHttpInfo($user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listTaggingsWithHttpInfo
     *
     * List taggings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaggings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaggingsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTaggingsWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaggings'][0])
    {
        $request = $this->listTaggingsRequest($user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TaggingsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TaggingsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaggingsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTaggingsAsync
     *
     * List taggings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaggings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaggingsAsync($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaggings'][0])
    {
        return $this->listTaggingsAsyncWithHttpInfo($user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTaggingsAsyncWithHttpInfo
     *
     * List taggings
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaggings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaggingsAsyncWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaggings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TaggingsResponseBody';
        $request = $this->listTaggingsRequest($user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTaggings'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaggings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTaggingsRequest($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaggings'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listTaggings'
            );
        }




        $resourcePath = '/users/{user_guid}/taggings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTags
     *
     * List tags
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TagsResponseBody
     */
    public function listTags($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTags'][0])
    {
        list($response) = $this->listTagsWithHttpInfo($user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listTagsWithHttpInfo
     *
     * List tags
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TagsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTagsWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTags'][0])
    {
        $request = $this->listTagsRequest($user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TagsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TagsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TagsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTagsAsync
     *
     * List tags
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagsAsync($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTags'][0])
    {
        return $this->listTagsAsyncWithHttpInfo($user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTagsAsyncWithHttpInfo
     *
     * List tags
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagsAsyncWithHttpInfo($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TagsResponseBody';
        $request = $this->listTagsRequest($user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTags'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTagsRequest($user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTags'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listTags'
            );
        }




        $resourcePath = '/users/{user_guid}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTaxDocuments
     *
     * List Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaxDocumentsResponseBody
     */
    public function listTaxDocuments($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaxDocuments'][0])
    {
        list($response) = $this->listTaxDocumentsWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listTaxDocumentsWithHttpInfo
     *
     * List Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaxDocumentsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTaxDocumentsWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaxDocuments'][0])
    {
        $request = $this->listTaxDocumentsRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TaxDocumentsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TaxDocumentsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaxDocumentsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTaxDocumentsAsync
     *
     * List Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaxDocumentsAsync($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaxDocuments'][0])
    {
        return $this->listTaxDocumentsAsyncWithHttpInfo($member_guid, $user_guid, $page, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTaxDocumentsAsyncWithHttpInfo
     *
     * List Tax Documents
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaxDocumentsAsyncWithHttpInfo($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaxDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TaxDocumentsResponseBody';
        $request = $this->listTaxDocumentsRequest($member_guid, $user_guid, $page, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTaxDocuments'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTaxDocumentsRequest($member_guid, $user_guid, $page = null, $records_per_page = null, string $contentType = self::contentTypes['listTaxDocuments'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling listTaxDocuments'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listTaxDocuments'
            );
        }




        $resourcePath = '/users/{user_guid}/members/{member_guid}/tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUserAccounts
     *
     * List accounts
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  bool|null $is_manual List only accounts that were manually created. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountsResponseBody
     */
    public function listUserAccounts($user_guid, $member_is_managed_by_user = null, $page = null, $is_manual = null, $records_per_page = null, string $contentType = self::contentTypes['listUserAccounts'][0])
    {
        list($response) = $this->listUserAccountsWithHttpInfo($user_guid, $member_is_managed_by_user, $page, $is_manual, $records_per_page, $contentType);
        return $response;
    }

    /**
     * Operation listUserAccountsWithHttpInfo
     *
     * List accounts
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  bool|null $is_manual List only accounts that were manually created. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountsResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUserAccountsWithHttpInfo($user_guid, $member_is_managed_by_user = null, $page = null, $is_manual = null, $records_per_page = null, string $contentType = self::contentTypes['listUserAccounts'][0])
    {
        $request = $this->listUserAccountsRequest($user_guid, $member_is_managed_by_user, $page, $is_manual, $records_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountsResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountsResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountsResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listUserAccountsAsync
     *
     * List accounts
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  bool|null $is_manual List only accounts that were manually created. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUserAccountsAsync($user_guid, $member_is_managed_by_user = null, $page = null, $is_manual = null, $records_per_page = null, string $contentType = self::contentTypes['listUserAccounts'][0])
    {
        return $this->listUserAccountsAsyncWithHttpInfo($user_guid, $member_is_managed_by_user, $page, $is_manual, $records_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUserAccountsAsyncWithHttpInfo
     *
     * List accounts
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  bool|null $is_manual List only accounts that were manually created. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUserAccountsAsyncWithHttpInfo($user_guid, $member_is_managed_by_user = null, $page = null, $is_manual = null, $records_per_page = null, string $contentType = self::contentTypes['listUserAccounts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountsResponseBody';
        $request = $this->listUserAccountsRequest($user_guid, $member_is_managed_by_user, $page, $is_manual, $records_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUserAccounts'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  bool|null $member_is_managed_by_user List only accounts whose member is managed by the user. (optional)
     * @param  int|null $page Specify current page. (optional)
     * @param  bool|null $is_manual List only accounts that were manually created. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUserAccountsRequest($user_guid, $member_is_managed_by_user = null, $page = null, $is_manual = null, $records_per_page = null, string $contentType = self::contentTypes['listUserAccounts'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling listUserAccounts'
            );
        }






        $resourcePath = '/users/{user_guid}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $member_is_managed_by_user,
            'member_is_managed_by_user', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_manual,
            'is_manual', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsers
     *
     * List users
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $id The user &#x60;id&#x60; to search for. (optional)
     * @param  string|null $email The user &#x60;email&#x60; to search for. (optional)
     * @param  bool|null $is_disabled Search for users that are diabled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UsersResponseBody
     */
    public function listUsers($page = null, $records_per_page = null, $id = null, $email = null, $is_disabled = null, string $contentType = self::contentTypes['listUsers'][0])
    {
        list($response) = $this->listUsersWithHttpInfo($page, $records_per_page, $id, $email, $is_disabled, $contentType);
        return $response;
    }

    /**
     * Operation listUsersWithHttpInfo
     *
     * List users
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $id The user &#x60;id&#x60; to search for. (optional)
     * @param  string|null $email The user &#x60;email&#x60; to search for. (optional)
     * @param  bool|null $is_disabled Search for users that are diabled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UsersResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUsersWithHttpInfo($page = null, $records_per_page = null, $id = null, $email = null, $is_disabled = null, string $contentType = self::contentTypes['listUsers'][0])
    {
        $request = $this->listUsersRequest($page, $records_per_page, $id, $email, $is_disabled, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UsersResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UsersResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UsersResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listUsersAsync
     *
     * List users
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $id The user &#x60;id&#x60; to search for. (optional)
     * @param  string|null $email The user &#x60;email&#x60; to search for. (optional)
     * @param  bool|null $is_disabled Search for users that are diabled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsync($page = null, $records_per_page = null, $id = null, $email = null, $is_disabled = null, string $contentType = self::contentTypes['listUsers'][0])
    {
        return $this->listUsersAsyncWithHttpInfo($page, $records_per_page, $id, $email, $is_disabled, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUsersAsyncWithHttpInfo
     *
     * List users
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $id The user &#x60;id&#x60; to search for. (optional)
     * @param  string|null $email The user &#x60;email&#x60; to search for. (optional)
     * @param  bool|null $is_disabled Search for users that are diabled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsyncWithHttpInfo($page = null, $records_per_page = null, $id = null, $email = null, $is_disabled = null, string $contentType = self::contentTypes['listUsers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UsersResponseBody';
        $request = $this->listUsersRequest($page, $records_per_page, $id, $email, $is_disabled, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUsers'
     *
     * @param  int|null $page Specify current page. (optional)
     * @param  int|null $records_per_page Specify records per page. (optional)
     * @param  string|null $id The user &#x60;id&#x60; to search for. (optional)
     * @param  string|null $email The user &#x60;email&#x60; to search for. (optional)
     * @param  bool|null $is_disabled Search for users that are diabled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUsersRequest($page = null, $records_per_page = null, $id = null, $email = null, $is_disabled = null, string $contentType = self::contentTypes['listUsers'][0])
    {







        $resourcePath = '/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $records_per_page,
            'records_per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_disabled,
            'is_disabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readAccount
     *
     * Read account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function readAccount($account_guid, $user_guid, string $contentType = self::contentTypes['readAccount'][0])
    {
        list($response) = $this->readAccountWithHttpInfo($account_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readAccountWithHttpInfo
     *
     * Read account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readAccountWithHttpInfo($account_guid, $user_guid, string $contentType = self::contentTypes['readAccount'][0])
    {
        $request = $this->readAccountRequest($account_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readAccountAsync
     *
     * Read account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readAccountAsync($account_guid, $user_guid, string $contentType = self::contentTypes['readAccount'][0])
    {
        return $this->readAccountAsyncWithHttpInfo($account_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readAccountAsyncWithHttpInfo
     *
     * Read account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readAccountAsyncWithHttpInfo($account_guid, $user_guid, string $contentType = self::contentTypes['readAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->readAccountRequest($account_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readAccount'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readAccountRequest($account_guid, $user_guid, string $contentType = self::contentTypes['readAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling readAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readAccountByMember
     *
     * Read account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccountByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function readAccountByMember($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readAccountByMember'][0])
    {
        list($response) = $this->readAccountByMemberWithHttpInfo($account_guid, $member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readAccountByMemberWithHttpInfo
     *
     * Read account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccountByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readAccountByMemberWithHttpInfo($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readAccountByMember'][0])
    {
        $request = $this->readAccountByMemberRequest($account_guid, $member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readAccountByMemberAsync
     *
     * Read account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccountByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readAccountByMemberAsync($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readAccountByMember'][0])
    {
        return $this->readAccountByMemberAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readAccountByMemberAsyncWithHttpInfo
     *
     * Read account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccountByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readAccountByMemberAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readAccountByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->readAccountByMemberRequest($account_guid, $member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readAccountByMember'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readAccountByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readAccountByMemberRequest($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readAccountByMember'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling readAccountByMember'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readAccountByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readAccountByMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readHolding
     *
     * Read holding
     *
     * @param  string $holding_guid The unique id for a &#x60;holding&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readHolding'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HoldingResponseBody
     */
    public function readHolding($holding_guid, $user_guid, string $contentType = self::contentTypes['readHolding'][0])
    {
        list($response) = $this->readHoldingWithHttpInfo($holding_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readHoldingWithHttpInfo
     *
     * Read holding
     *
     * @param  string $holding_guid The unique id for a &#x60;holding&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readHolding'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HoldingResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readHoldingWithHttpInfo($holding_guid, $user_guid, string $contentType = self::contentTypes['readHolding'][0])
    {
        $request = $this->readHoldingRequest($holding_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HoldingResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HoldingResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HoldingResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readHoldingAsync
     *
     * Read holding
     *
     * @param  string $holding_guid The unique id for a &#x60;holding&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readHolding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readHoldingAsync($holding_guid, $user_guid, string $contentType = self::contentTypes['readHolding'][0])
    {
        return $this->readHoldingAsyncWithHttpInfo($holding_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readHoldingAsyncWithHttpInfo
     *
     * Read holding
     *
     * @param  string $holding_guid The unique id for a &#x60;holding&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readHolding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readHoldingAsyncWithHttpInfo($holding_guid, $user_guid, string $contentType = self::contentTypes['readHolding'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HoldingResponseBody';
        $request = $this->readHoldingRequest($holding_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readHolding'
     *
     * @param  string $holding_guid The unique id for a &#x60;holding&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readHolding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readHoldingRequest($holding_guid, $user_guid, string $contentType = self::contentTypes['readHolding'][0])
    {

        // verify the required parameter 'holding_guid' is set
        if ($holding_guid === null || (is_array($holding_guid) && count($holding_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $holding_guid when calling readHolding'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readHolding'
            );
        }


        $resourcePath = '/users/{user_guid}/holdings/{holding_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($holding_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'holding_guid' . '}',
                ObjectSerializer::toPathValue($holding_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readInstitution
     *
     * Read institution
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readInstitution'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InstitutionResponseBody
     */
    public function readInstitution($institution_code, string $contentType = self::contentTypes['readInstitution'][0])
    {
        list($response) = $this->readInstitutionWithHttpInfo($institution_code, $contentType);
        return $response;
    }

    /**
     * Operation readInstitutionWithHttpInfo
     *
     * Read institution
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readInstitution'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InstitutionResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readInstitutionWithHttpInfo($institution_code, string $contentType = self::contentTypes['readInstitution'][0])
    {
        $request = $this->readInstitutionRequest($institution_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InstitutionResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InstitutionResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InstitutionResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readInstitutionAsync
     *
     * Read institution
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readInstitution'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readInstitutionAsync($institution_code, string $contentType = self::contentTypes['readInstitution'][0])
    {
        return $this->readInstitutionAsyncWithHttpInfo($institution_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readInstitutionAsyncWithHttpInfo
     *
     * Read institution
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readInstitution'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readInstitutionAsyncWithHttpInfo($institution_code, string $contentType = self::contentTypes['readInstitution'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InstitutionResponseBody';
        $request = $this->readInstitutionRequest($institution_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readInstitution'
     *
     * @param  string $institution_code The institution_code of the institution. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readInstitution'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readInstitutionRequest($institution_code, string $contentType = self::contentTypes['readInstitution'][0])
    {

        // verify the required parameter 'institution_code' is set
        if ($institution_code === null || (is_array($institution_code) && count($institution_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $institution_code when calling readInstitution'
            );
        }


        $resourcePath = '/institutions/{institution_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($institution_code !== null) {
            $resourcePath = str_replace(
                '{' . 'institution_code' . '}',
                ObjectSerializer::toPathValue($institution_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readManagedAccount
     *
     * Read managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function readManagedAccount($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readManagedAccount'][0])
    {
        list($response) = $this->readManagedAccountWithHttpInfo($account_guid, $member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readManagedAccountWithHttpInfo
     *
     * Read managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readManagedAccountWithHttpInfo($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readManagedAccount'][0])
    {
        $request = $this->readManagedAccountRequest($account_guid, $member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readManagedAccountAsync
     *
     * Read managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readManagedAccountAsync($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readManagedAccount'][0])
    {
        return $this->readManagedAccountAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readManagedAccountAsyncWithHttpInfo
     *
     * Read managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readManagedAccountAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readManagedAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->readManagedAccountRequest($account_guid, $member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readManagedAccount'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readManagedAccountRequest($account_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readManagedAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling readManagedAccount'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readManagedAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readManagedAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readManagedMember
     *
     * Read managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function readManagedMember($member_guid, $user_guid, string $contentType = self::contentTypes['readManagedMember'][0])
    {
        list($response) = $this->readManagedMemberWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readManagedMemberWithHttpInfo
     *
     * Read managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readManagedMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['readManagedMember'][0])
    {
        $request = $this->readManagedMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readManagedMemberAsync
     *
     * Read managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readManagedMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['readManagedMember'][0])
    {
        return $this->readManagedMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readManagedMemberAsyncWithHttpInfo
     *
     * Read managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readManagedMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['readManagedMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->readManagedMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readManagedMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readManagedMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['readManagedMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readManagedMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readManagedMember'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readMember
     *
     * Read member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function readMember($member_guid, $user_guid, string $contentType = self::contentTypes['readMember'][0])
    {
        list($response) = $this->readMemberWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readMemberWithHttpInfo
     *
     * Read member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['readMember'][0])
    {
        $request = $this->readMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readMemberAsync
     *
     * Read member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['readMember'][0])
    {
        return $this->readMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readMemberAsyncWithHttpInfo
     *
     * Read member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['readMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->readMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['readMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readMemberStatus
     *
     * Read member status
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMemberStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberStatusResponseBody
     */
    public function readMemberStatus($member_guid, $user_guid, string $contentType = self::contentTypes['readMemberStatus'][0])
    {
        list($response) = $this->readMemberStatusWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readMemberStatusWithHttpInfo
     *
     * Read member status
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMemberStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberStatusResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readMemberStatusWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['readMemberStatus'][0])
    {
        $request = $this->readMemberStatusRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberStatusResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberStatusResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberStatusResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readMemberStatusAsync
     *
     * Read member status
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMemberStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMemberStatusAsync($member_guid, $user_guid, string $contentType = self::contentTypes['readMemberStatus'][0])
    {
        return $this->readMemberStatusAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readMemberStatusAsyncWithHttpInfo
     *
     * Read member status
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMemberStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMemberStatusAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['readMemberStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberStatusResponseBody';
        $request = $this->readMemberStatusRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readMemberStatus'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMemberStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readMemberStatusRequest($member_guid, $user_guid, string $contentType = self::contentTypes['readMemberStatus'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readMemberStatus'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readMemberStatus'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readMerchant
     *
     * Read merchant
     *
     * @param  string $merchant_guid The unique id for a &#x60;merchant&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchant'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MerchantResponseBody
     */
    public function readMerchant($merchant_guid, string $contentType = self::contentTypes['readMerchant'][0])
    {
        list($response) = $this->readMerchantWithHttpInfo($merchant_guid, $contentType);
        return $response;
    }

    /**
     * Operation readMerchantWithHttpInfo
     *
     * Read merchant
     *
     * @param  string $merchant_guid The unique id for a &#x60;merchant&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchant'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MerchantResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readMerchantWithHttpInfo($merchant_guid, string $contentType = self::contentTypes['readMerchant'][0])
    {
        $request = $this->readMerchantRequest($merchant_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MerchantResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MerchantResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MerchantResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readMerchantAsync
     *
     * Read merchant
     *
     * @param  string $merchant_guid The unique id for a &#x60;merchant&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMerchantAsync($merchant_guid, string $contentType = self::contentTypes['readMerchant'][0])
    {
        return $this->readMerchantAsyncWithHttpInfo($merchant_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readMerchantAsyncWithHttpInfo
     *
     * Read merchant
     *
     * @param  string $merchant_guid The unique id for a &#x60;merchant&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMerchantAsyncWithHttpInfo($merchant_guid, string $contentType = self::contentTypes['readMerchant'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MerchantResponseBody';
        $request = $this->readMerchantRequest($merchant_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readMerchant'
     *
     * @param  string $merchant_guid The unique id for a &#x60;merchant&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readMerchantRequest($merchant_guid, string $contentType = self::contentTypes['readMerchant'][0])
    {

        // verify the required parameter 'merchant_guid' is set
        if ($merchant_guid === null || (is_array($merchant_guid) && count($merchant_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_guid when calling readMerchant'
            );
        }


        $resourcePath = '/merchants/{merchant_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'merchant_guid' . '}',
                ObjectSerializer::toPathValue($merchant_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readMerchantLocation
     *
     * Read merchant location
     *
     * @param  string $merchant_location_guid The unique id for a &#x60;merchant_location&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchantLocation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MerchantLocationResponseBody
     */
    public function readMerchantLocation($merchant_location_guid, string $contentType = self::contentTypes['readMerchantLocation'][0])
    {
        list($response) = $this->readMerchantLocationWithHttpInfo($merchant_location_guid, $contentType);
        return $response;
    }

    /**
     * Operation readMerchantLocationWithHttpInfo
     *
     * Read merchant location
     *
     * @param  string $merchant_location_guid The unique id for a &#x60;merchant_location&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchantLocation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MerchantLocationResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readMerchantLocationWithHttpInfo($merchant_location_guid, string $contentType = self::contentTypes['readMerchantLocation'][0])
    {
        $request = $this->readMerchantLocationRequest($merchant_location_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MerchantLocationResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MerchantLocationResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MerchantLocationResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readMerchantLocationAsync
     *
     * Read merchant location
     *
     * @param  string $merchant_location_guid The unique id for a &#x60;merchant_location&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchantLocation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMerchantLocationAsync($merchant_location_guid, string $contentType = self::contentTypes['readMerchantLocation'][0])
    {
        return $this->readMerchantLocationAsyncWithHttpInfo($merchant_location_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readMerchantLocationAsyncWithHttpInfo
     *
     * Read merchant location
     *
     * @param  string $merchant_location_guid The unique id for a &#x60;merchant_location&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchantLocation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readMerchantLocationAsyncWithHttpInfo($merchant_location_guid, string $contentType = self::contentTypes['readMerchantLocation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MerchantLocationResponseBody';
        $request = $this->readMerchantLocationRequest($merchant_location_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readMerchantLocation'
     *
     * @param  string $merchant_location_guid The unique id for a &#x60;merchant_location&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readMerchantLocation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readMerchantLocationRequest($merchant_location_guid, string $contentType = self::contentTypes['readMerchantLocation'][0])
    {

        // verify the required parameter 'merchant_location_guid' is set
        if ($merchant_location_guid === null || (is_array($merchant_location_guid) && count($merchant_location_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_location_guid when calling readMerchantLocation'
            );
        }


        $resourcePath = '/merchant_locations/{merchant_location_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_location_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'merchant_location_guid' . '}',
                ObjectSerializer::toPathValue($merchant_location_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readRewards
     *
     * Read Reward
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $reward_guid The unique identifier for the rewards. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readRewards'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RewardResponseBody
     */
    public function readRewards($user_guid, $member_guid, $reward_guid, string $contentType = self::contentTypes['readRewards'][0])
    {
        list($response) = $this->readRewardsWithHttpInfo($user_guid, $member_guid, $reward_guid, $contentType);
        return $response;
    }

    /**
     * Operation readRewardsWithHttpInfo
     *
     * Read Reward
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $reward_guid The unique identifier for the rewards. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readRewards'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RewardResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readRewardsWithHttpInfo($user_guid, $member_guid, $reward_guid, string $contentType = self::contentTypes['readRewards'][0])
    {
        $request = $this->readRewardsRequest($user_guid, $member_guid, $reward_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RewardResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RewardResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RewardResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readRewardsAsync
     *
     * Read Reward
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $reward_guid The unique identifier for the rewards. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readRewardsAsync($user_guid, $member_guid, $reward_guid, string $contentType = self::contentTypes['readRewards'][0])
    {
        return $this->readRewardsAsyncWithHttpInfo($user_guid, $member_guid, $reward_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readRewardsAsyncWithHttpInfo
     *
     * Read Reward
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $reward_guid The unique identifier for the rewards. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readRewardsAsyncWithHttpInfo($user_guid, $member_guid, $reward_guid, string $contentType = self::contentTypes['readRewards'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RewardResponseBody';
        $request = $this->readRewardsRequest($user_guid, $member_guid, $reward_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readRewards'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $member_guid The unique identifier for the member. Defined by MX. (required)
     * @param  string $reward_guid The unique identifier for the rewards. Defined by MX. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readRewardsRequest($user_guid, $member_guid, $reward_guid, string $contentType = self::contentTypes['readRewards'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readRewards'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readRewards'
            );
        }

        // verify the required parameter 'reward_guid' is set
        if ($reward_guid === null || (is_array($reward_guid) && count($reward_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reward_guid when calling readRewards'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/rewards/{reward_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($reward_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'reward_guid' . '}',
                ObjectSerializer::toPathValue($reward_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readStatementByMember
     *
     * Read statement by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readStatementByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StatementResponseBody
     */
    public function readStatementByMember($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['readStatementByMember'][0])
    {
        list($response) = $this->readStatementByMemberWithHttpInfo($member_guid, $statement_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readStatementByMemberWithHttpInfo
     *
     * Read statement by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readStatementByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StatementResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readStatementByMemberWithHttpInfo($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['readStatementByMember'][0])
    {
        $request = $this->readStatementByMemberRequest($member_guid, $statement_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StatementResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StatementResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StatementResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readStatementByMemberAsync
     *
     * Read statement by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readStatementByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readStatementByMemberAsync($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['readStatementByMember'][0])
    {
        return $this->readStatementByMemberAsyncWithHttpInfo($member_guid, $statement_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readStatementByMemberAsyncWithHttpInfo
     *
     * Read statement by member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readStatementByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readStatementByMemberAsyncWithHttpInfo($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['readStatementByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StatementResponseBody';
        $request = $this->readStatementByMemberRequest($member_guid, $statement_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readStatementByMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $statement_guid The unique id for a &#x60;statement&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readStatementByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readStatementByMemberRequest($member_guid, $statement_guid, $user_guid, string $contentType = self::contentTypes['readStatementByMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readStatementByMember'
            );
        }

        // verify the required parameter 'statement_guid' is set
        if ($statement_guid === null || (is_array($statement_guid) && count($statement_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $statement_guid when calling readStatementByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readStatementByMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/statements/{statement_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($statement_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'statement_guid' . '}',
                ObjectSerializer::toPathValue($statement_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readTag
     *
     * Read tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TagResponseBody
     */
    public function readTag($tag_guid, $user_guid, string $contentType = self::contentTypes['readTag'][0])
    {
        list($response) = $this->readTagWithHttpInfo($tag_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readTagWithHttpInfo
     *
     * Read tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TagResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readTagWithHttpInfo($tag_guid, $user_guid, string $contentType = self::contentTypes['readTag'][0])
    {
        $request = $this->readTagRequest($tag_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TagResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TagResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TagResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readTagAsync
     *
     * Read tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readTagAsync($tag_guid, $user_guid, string $contentType = self::contentTypes['readTag'][0])
    {
        return $this->readTagAsyncWithHttpInfo($tag_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readTagAsyncWithHttpInfo
     *
     * Read tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readTagAsyncWithHttpInfo($tag_guid, $user_guid, string $contentType = self::contentTypes['readTag'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TagResponseBody';
        $request = $this->readTagRequest($tag_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readTag'
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readTagRequest($tag_guid, $user_guid, string $contentType = self::contentTypes['readTag'][0])
    {

        // verify the required parameter 'tag_guid' is set
        if ($tag_guid === null || (is_array($tag_guid) && count($tag_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_guid when calling readTag'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readTag'
            );
        }


        $resourcePath = '/users/{user_guid}/tags/{tag_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tag_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tag_guid' . '}',
                ObjectSerializer::toPathValue($tag_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readTagging
     *
     * Read tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaggingResponseBody
     */
    public function readTagging($tagging_guid, $user_guid, string $contentType = self::contentTypes['readTagging'][0])
    {
        list($response) = $this->readTaggingWithHttpInfo($tagging_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readTaggingWithHttpInfo
     *
     * Read tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaggingResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readTaggingWithHttpInfo($tagging_guid, $user_guid, string $contentType = self::contentTypes['readTagging'][0])
    {
        $request = $this->readTaggingRequest($tagging_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TaggingResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TaggingResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaggingResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readTaggingAsync
     *
     * Read tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readTaggingAsync($tagging_guid, $user_guid, string $contentType = self::contentTypes['readTagging'][0])
    {
        return $this->readTaggingAsyncWithHttpInfo($tagging_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readTaggingAsyncWithHttpInfo
     *
     * Read tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readTaggingAsyncWithHttpInfo($tagging_guid, $user_guid, string $contentType = self::contentTypes['readTagging'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TaggingResponseBody';
        $request = $this->readTaggingRequest($tagging_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readTagging'
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readTaggingRequest($tagging_guid, $user_guid, string $contentType = self::contentTypes['readTagging'][0])
    {

        // verify the required parameter 'tagging_guid' is set
        if ($tagging_guid === null || (is_array($tagging_guid) && count($tagging_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagging_guid when calling readTagging'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readTagging'
            );
        }


        $resourcePath = '/users/{user_guid}/taggings/{tagging_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tagging_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tagging_guid' . '}',
                ObjectSerializer::toPathValue($tagging_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readTaxDocument
     *
     * Read a Tax Document
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaxDocumentResponseBody
     */
    public function readTaxDocument($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readTaxDocument'][0])
    {
        list($response) = $this->readTaxDocumentWithHttpInfo($tax_document_guid, $member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readTaxDocumentWithHttpInfo
     *
     * Read a Tax Document
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaxDocumentResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readTaxDocumentWithHttpInfo($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readTaxDocument'][0])
    {
        $request = $this->readTaxDocumentRequest($tax_document_guid, $member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TaxDocumentResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TaxDocumentResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaxDocumentResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readTaxDocumentAsync
     *
     * Read a Tax Document
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readTaxDocumentAsync($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readTaxDocument'][0])
    {
        return $this->readTaxDocumentAsyncWithHttpInfo($tax_document_guid, $member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readTaxDocumentAsyncWithHttpInfo
     *
     * Read a Tax Document
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readTaxDocumentAsyncWithHttpInfo($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readTaxDocument'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TaxDocumentResponseBody';
        $request = $this->readTaxDocumentRequest($tax_document_guid, $member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readTaxDocument'
     *
     * @param  string $tax_document_guid The unique id for a &#x60;tax_document&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readTaxDocumentRequest($tax_document_guid, $member_guid, $user_guid, string $contentType = self::contentTypes['readTaxDocument'][0])
    {

        // verify the required parameter 'tax_document_guid' is set
        if ($tax_document_guid === null || (is_array($tax_document_guid) && count($tax_document_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_document_guid when calling readTaxDocument'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling readTaxDocument'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readTaxDocument'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/tax_documents/{tax_document_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tax_document_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tax_document_guid' . '}',
                ObjectSerializer::toPathValue($tax_document_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readUser
     *
     * Read user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserResponseBody
     */
    public function readUser($user_guid, string $contentType = self::contentTypes['readUser'][0])
    {
        list($response) = $this->readUserWithHttpInfo($user_guid, $contentType);
        return $response;
    }

    /**
     * Operation readUserWithHttpInfo
     *
     * Read user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function readUserWithHttpInfo($user_guid, string $contentType = self::contentTypes['readUser'][0])
    {
        $request = $this->readUserRequest($user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UserResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UserResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation readUserAsync
     *
     * Read user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readUserAsync($user_guid, string $contentType = self::contentTypes['readUser'][0])
    {
        return $this->readUserAsyncWithHttpInfo($user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readUserAsyncWithHttpInfo
     *
     * Read user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readUserAsyncWithHttpInfo($user_guid, string $contentType = self::contentTypes['readUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UserResponseBody';
        $request = $this->readUserRequest($user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readUser'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['readUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function readUserRequest($user_guid, string $contentType = self::contentTypes['readUser'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling readUser'
            );
        }


        $resourcePath = '/users/{user_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestAuthorizationCode
     *
     * Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\AuthorizationCodeRequestBody $authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AuthorizationCodeResponseBody
     */
    public function requestAuthorizationCode($authorization_code_request_body, string $contentType = self::contentTypes['requestAuthorizationCode'][0])
    {
        list($response) = $this->requestAuthorizationCodeWithHttpInfo($authorization_code_request_body, $contentType);
        return $response;
    }

    /**
     * Operation requestAuthorizationCodeWithHttpInfo
     *
     * Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\AuthorizationCodeRequestBody $authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AuthorizationCodeResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestAuthorizationCodeWithHttpInfo($authorization_code_request_body, string $contentType = self::contentTypes['requestAuthorizationCode'][0])
    {
        $request = $this->requestAuthorizationCodeRequest($authorization_code_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AuthorizationCodeResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AuthorizationCodeResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AuthorizationCodeResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation requestAuthorizationCodeAsync
     *
     * Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\AuthorizationCodeRequestBody $authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestAuthorizationCodeAsync($authorization_code_request_body, string $contentType = self::contentTypes['requestAuthorizationCode'][0])
    {
        return $this->requestAuthorizationCodeAsyncWithHttpInfo($authorization_code_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestAuthorizationCodeAsyncWithHttpInfo
     *
     * Request an authorization code.
     *
     * @param  \OpenAPI\Client\Model\AuthorizationCodeRequestBody $authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestAuthorizationCodeAsyncWithHttpInfo($authorization_code_request_body, string $contentType = self::contentTypes['requestAuthorizationCode'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AuthorizationCodeResponseBody';
        $request = $this->requestAuthorizationCodeRequest($authorization_code_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestAuthorizationCode'
     *
     * @param  \OpenAPI\Client\Model\AuthorizationCodeRequestBody $authorization_code_request_body The scope for the authorization code. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestAuthorizationCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestAuthorizationCodeRequest($authorization_code_request_body, string $contentType = self::contentTypes['requestAuthorizationCode'][0])
    {

        // verify the required parameter 'authorization_code_request_body' is set
        if ($authorization_code_request_body === null || (is_array($authorization_code_request_body) && count($authorization_code_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization_code_request_body when calling requestAuthorizationCode'
            );
        }


        $resourcePath = '/authorization_code';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authorization_code_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authorization_code_request_body));
            } else {
                $httpBody = $authorization_code_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestConnectWidgetURL
     *
     * Request connect widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ConnectWidgetRequestBody $connect_widget_request_body Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestConnectWidgetURL'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConnectWidgetResponseBody
     */
    public function requestConnectWidgetURL($user_guid, $connect_widget_request_body, string $contentType = self::contentTypes['requestConnectWidgetURL'][0])
    {
        list($response) = $this->requestConnectWidgetURLWithHttpInfo($user_guid, $connect_widget_request_body, $contentType);
        return $response;
    }

    /**
     * Operation requestConnectWidgetURLWithHttpInfo
     *
     * Request connect widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ConnectWidgetRequestBody $connect_widget_request_body Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestConnectWidgetURL'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConnectWidgetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestConnectWidgetURLWithHttpInfo($user_guid, $connect_widget_request_body, string $contentType = self::contentTypes['requestConnectWidgetURL'][0])
    {
        $request = $this->requestConnectWidgetURLRequest($user_guid, $connect_widget_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ConnectWidgetResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ConnectWidgetResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConnectWidgetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation requestConnectWidgetURLAsync
     *
     * Request connect widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ConnectWidgetRequestBody $connect_widget_request_body Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestConnectWidgetURL'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestConnectWidgetURLAsync($user_guid, $connect_widget_request_body, string $contentType = self::contentTypes['requestConnectWidgetURL'][0])
    {
        return $this->requestConnectWidgetURLAsyncWithHttpInfo($user_guid, $connect_widget_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestConnectWidgetURLAsyncWithHttpInfo
     *
     * Request connect widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ConnectWidgetRequestBody $connect_widget_request_body Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestConnectWidgetURL'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestConnectWidgetURLAsyncWithHttpInfo($user_guid, $connect_widget_request_body, string $contentType = self::contentTypes['requestConnectWidgetURL'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConnectWidgetResponseBody';
        $request = $this->requestConnectWidgetURLRequest($user_guid, $connect_widget_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestConnectWidgetURL'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ConnectWidgetRequestBody $connect_widget_request_body Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestConnectWidgetURL'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestConnectWidgetURLRequest($user_guid, $connect_widget_request_body, string $contentType = self::contentTypes['requestConnectWidgetURL'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling requestConnectWidgetURL'
            );
        }

        // verify the required parameter 'connect_widget_request_body' is set
        if ($connect_widget_request_body === null || (is_array($connect_widget_request_body) && count($connect_widget_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connect_widget_request_body when calling requestConnectWidgetURL'
            );
        }


        $resourcePath = '/users/{user_guid}/connect_widget_url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connect_widget_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connect_widget_request_body));
            } else {
                $httpBody = $connect_widget_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestOAuthWindowURI
     *
     * Request oauth window uri
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $client_redirect_url A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string|null $enable_app2app This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. This setting is not persistent. (optional)
     * @param  string|null $referral_source Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;. (optional)
     * @param  bool|null $skip_aggregation Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page. (optional)
     * @param  string|null $ui_message_webview_url_scheme A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestOAuthWindowURI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OAuthWindowResponseBody
     */
    public function requestOAuthWindowURI($member_guid, $user_guid, $client_redirect_url = null, $enable_app2app = null, $referral_source = null, $skip_aggregation = null, $ui_message_webview_url_scheme = null, string $contentType = self::contentTypes['requestOAuthWindowURI'][0])
    {
        list($response) = $this->requestOAuthWindowURIWithHttpInfo($member_guid, $user_guid, $client_redirect_url, $enable_app2app, $referral_source, $skip_aggregation, $ui_message_webview_url_scheme, $contentType);
        return $response;
    }

    /**
     * Operation requestOAuthWindowURIWithHttpInfo
     *
     * Request oauth window uri
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $client_redirect_url A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string|null $enable_app2app This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. This setting is not persistent. (optional)
     * @param  string|null $referral_source Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;. (optional)
     * @param  bool|null $skip_aggregation Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page. (optional)
     * @param  string|null $ui_message_webview_url_scheme A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestOAuthWindowURI'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OAuthWindowResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestOAuthWindowURIWithHttpInfo($member_guid, $user_guid, $client_redirect_url = null, $enable_app2app = null, $referral_source = null, $skip_aggregation = null, $ui_message_webview_url_scheme = null, string $contentType = self::contentTypes['requestOAuthWindowURI'][0])
    {
        $request = $this->requestOAuthWindowURIRequest($member_guid, $user_guid, $client_redirect_url, $enable_app2app, $referral_source, $skip_aggregation, $ui_message_webview_url_scheme, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OAuthWindowResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OAuthWindowResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OAuthWindowResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation requestOAuthWindowURIAsync
     *
     * Request oauth window uri
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $client_redirect_url A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string|null $enable_app2app This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. This setting is not persistent. (optional)
     * @param  string|null $referral_source Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;. (optional)
     * @param  bool|null $skip_aggregation Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page. (optional)
     * @param  string|null $ui_message_webview_url_scheme A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestOAuthWindowURI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestOAuthWindowURIAsync($member_guid, $user_guid, $client_redirect_url = null, $enable_app2app = null, $referral_source = null, $skip_aggregation = null, $ui_message_webview_url_scheme = null, string $contentType = self::contentTypes['requestOAuthWindowURI'][0])
    {
        return $this->requestOAuthWindowURIAsyncWithHttpInfo($member_guid, $user_guid, $client_redirect_url, $enable_app2app, $referral_source, $skip_aggregation, $ui_message_webview_url_scheme, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestOAuthWindowURIAsyncWithHttpInfo
     *
     * Request oauth window uri
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $client_redirect_url A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string|null $enable_app2app This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. This setting is not persistent. (optional)
     * @param  string|null $referral_source Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;. (optional)
     * @param  bool|null $skip_aggregation Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page. (optional)
     * @param  string|null $ui_message_webview_url_scheme A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestOAuthWindowURI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestOAuthWindowURIAsyncWithHttpInfo($member_guid, $user_guid, $client_redirect_url = null, $enable_app2app = null, $referral_source = null, $skip_aggregation = null, $ui_message_webview_url_scheme = null, string $contentType = self::contentTypes['requestOAuthWindowURI'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OAuthWindowResponseBody';
        $request = $this->requestOAuthWindowURIRequest($member_guid, $user_guid, $client_redirect_url, $enable_app2app, $referral_source, $skip_aggregation, $ui_message_webview_url_scheme, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestOAuthWindowURI'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string|null $client_redirect_url A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string|null $enable_app2app This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. This setting is not persistent. (optional)
     * @param  string|null $referral_source Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;. (optional)
     * @param  bool|null $skip_aggregation Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page. (optional)
     * @param  string|null $ui_message_webview_url_scheme A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestOAuthWindowURI'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestOAuthWindowURIRequest($member_guid, $user_guid, $client_redirect_url = null, $enable_app2app = null, $referral_source = null, $skip_aggregation = null, $ui_message_webview_url_scheme = null, string $contentType = self::contentTypes['requestOAuthWindowURI'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling requestOAuthWindowURI'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling requestOAuthWindowURI'
            );
        }







        $resourcePath = '/users/{user_guid}/members/{member_guid}/oauth_window_uri';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_redirect_url,
            'client_redirect_url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_app2app,
            'enable_app2app', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referral_source,
            'referral_source', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip_aggregation,
            'skip_aggregation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ui_message_webview_url_scheme,
            'ui_message_webview_url_scheme', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestWidgetURL
     *
     * Request widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\WidgetRequestBody $widget_request_body The widget url configuration options. (required)
     * @param  string|null $accept_language The desired language of the widget. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestWidgetURL'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WidgetResponseBody
     */
    public function requestWidgetURL($user_guid, $widget_request_body, $accept_language = null, string $contentType = self::contentTypes['requestWidgetURL'][0])
    {
        list($response) = $this->requestWidgetURLWithHttpInfo($user_guid, $widget_request_body, $accept_language, $contentType);
        return $response;
    }

    /**
     * Operation requestWidgetURLWithHttpInfo
     *
     * Request widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\WidgetRequestBody $widget_request_body The widget url configuration options. (required)
     * @param  string|null $accept_language The desired language of the widget. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestWidgetURL'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WidgetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestWidgetURLWithHttpInfo($user_guid, $widget_request_body, $accept_language = null, string $contentType = self::contentTypes['requestWidgetURL'][0])
    {
        $request = $this->requestWidgetURLRequest($user_guid, $widget_request_body, $accept_language, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\WidgetResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\WidgetResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WidgetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation requestWidgetURLAsync
     *
     * Request widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\WidgetRequestBody $widget_request_body The widget url configuration options. (required)
     * @param  string|null $accept_language The desired language of the widget. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestWidgetURL'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestWidgetURLAsync($user_guid, $widget_request_body, $accept_language = null, string $contentType = self::contentTypes['requestWidgetURL'][0])
    {
        return $this->requestWidgetURLAsyncWithHttpInfo($user_guid, $widget_request_body, $accept_language, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestWidgetURLAsyncWithHttpInfo
     *
     * Request widget url
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\WidgetRequestBody $widget_request_body The widget url configuration options. (required)
     * @param  string|null $accept_language The desired language of the widget. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestWidgetURL'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestWidgetURLAsyncWithHttpInfo($user_guid, $widget_request_body, $accept_language = null, string $contentType = self::contentTypes['requestWidgetURL'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WidgetResponseBody';
        $request = $this->requestWidgetURLRequest($user_guid, $widget_request_body, $accept_language, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestWidgetURL'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\WidgetRequestBody $widget_request_body The widget url configuration options. (required)
     * @param  string|null $accept_language The desired language of the widget. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestWidgetURL'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestWidgetURLRequest($user_guid, $widget_request_body, $accept_language = null, string $contentType = self::contentTypes['requestWidgetURL'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling requestWidgetURL'
            );
        }

        // verify the required parameter 'widget_request_body' is set
        if ($widget_request_body === null || (is_array($widget_request_body) && count($widget_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $widget_request_body when calling requestWidgetURL'
            );
        }



        $resourcePath = '/users/{user_guid}/widget_urls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($widget_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($widget_request_body));
            } else {
                $httpBody = $widget_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resumeAggregation
     *
     * Resume aggregation
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberResumeRequestBody $member_resume_request_body Member object with MFA challenge answers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resumeAggregation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function resumeAggregation($member_guid, $user_guid, $member_resume_request_body, string $contentType = self::contentTypes['resumeAggregation'][0])
    {
        list($response) = $this->resumeAggregationWithHttpInfo($member_guid, $user_guid, $member_resume_request_body, $contentType);
        return $response;
    }

    /**
     * Operation resumeAggregationWithHttpInfo
     *
     * Resume aggregation
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberResumeRequestBody $member_resume_request_body Member object with MFA challenge answers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resumeAggregation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function resumeAggregationWithHttpInfo($member_guid, $user_guid, $member_resume_request_body, string $contentType = self::contentTypes['resumeAggregation'][0])
    {
        $request = $this->resumeAggregationRequest($member_guid, $user_guid, $member_resume_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation resumeAggregationAsync
     *
     * Resume aggregation
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberResumeRequestBody $member_resume_request_body Member object with MFA challenge answers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resumeAggregation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resumeAggregationAsync($member_guid, $user_guid, $member_resume_request_body, string $contentType = self::contentTypes['resumeAggregation'][0])
    {
        return $this->resumeAggregationAsyncWithHttpInfo($member_guid, $user_guid, $member_resume_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resumeAggregationAsyncWithHttpInfo
     *
     * Resume aggregation
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberResumeRequestBody $member_resume_request_body Member object with MFA challenge answers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resumeAggregation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resumeAggregationAsyncWithHttpInfo($member_guid, $user_guid, $member_resume_request_body, string $contentType = self::contentTypes['resumeAggregation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->resumeAggregationRequest($member_guid, $user_guid, $member_resume_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resumeAggregation'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberResumeRequestBody $member_resume_request_body Member object with MFA challenge answers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resumeAggregation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resumeAggregationRequest($member_guid, $user_guid, $member_resume_request_body, string $contentType = self::contentTypes['resumeAggregation'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling resumeAggregation'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling resumeAggregation'
            );
        }

        // verify the required parameter 'member_resume_request_body' is set
        if ($member_resume_request_body === null || (is_array($member_resume_request_body) && count($member_resume_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_resume_request_body when calling resumeAggregation'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/resume';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($member_resume_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($member_resume_request_body));
            } else {
                $httpBody = $member_resume_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAccountByMember
     *
     * Update account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountUpdateRequestBody $account_update_request_body account_update_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAccountByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function updateAccountByMember($account_guid, $member_guid, $user_guid, $account_update_request_body, string $contentType = self::contentTypes['updateAccountByMember'][0])
    {
        list($response) = $this->updateAccountByMemberWithHttpInfo($account_guid, $member_guid, $user_guid, $account_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateAccountByMemberWithHttpInfo
     *
     * Update account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountUpdateRequestBody $account_update_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAccountByMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountByMemberWithHttpInfo($account_guid, $member_guid, $user_guid, $account_update_request_body, string $contentType = self::contentTypes['updateAccountByMember'][0])
    {
        $request = $this->updateAccountByMemberRequest($account_guid, $member_guid, $user_guid, $account_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateAccountByMemberAsync
     *
     * Update account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountUpdateRequestBody $account_update_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAccountByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAccountByMemberAsync($account_guid, $member_guid, $user_guid, $account_update_request_body, string $contentType = self::contentTypes['updateAccountByMember'][0])
    {
        return $this->updateAccountByMemberAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $account_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAccountByMemberAsyncWithHttpInfo
     *
     * Update account by member
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountUpdateRequestBody $account_update_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAccountByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAccountByMemberAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $account_update_request_body, string $contentType = self::contentTypes['updateAccountByMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->updateAccountByMemberRequest($account_guid, $member_guid, $user_guid, $account_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAccountByMember'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\AccountUpdateRequestBody $account_update_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAccountByMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAccountByMemberRequest($account_guid, $member_guid, $user_guid, $account_update_request_body, string $contentType = self::contentTypes['updateAccountByMember'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling updateAccountByMember'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling updateAccountByMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateAccountByMember'
            );
        }

        // verify the required parameter 'account_update_request_body' is set
        if ($account_update_request_body === null || (is_array($account_update_request_body) && count($account_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_update_request_body when calling updateAccountByMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($account_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($account_update_request_body));
            } else {
                $httpBody = $account_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCategory
     *
     * Update category
     *
     * @param  string $category_guid The unique id for a &#x60;category&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\CategoryUpdateRequestBody $category_update_request_body Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryResponseBody
     */
    public function updateCategory($category_guid, $user_guid, $category_update_request_body, string $contentType = self::contentTypes['updateCategory'][0])
    {
        list($response) = $this->updateCategoryWithHttpInfo($category_guid, $user_guid, $category_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateCategoryWithHttpInfo
     *
     * Update category
     *
     * @param  string $category_guid The unique id for a &#x60;category&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\CategoryUpdateRequestBody $category_update_request_body Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCategoryWithHttpInfo($category_guid, $user_guid, $category_update_request_body, string $contentType = self::contentTypes['updateCategory'][0])
    {
        $request = $this->updateCategoryRequest($category_guid, $user_guid, $category_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCategoryAsync
     *
     * Update category
     *
     * @param  string $category_guid The unique id for a &#x60;category&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\CategoryUpdateRequestBody $category_update_request_body Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCategoryAsync($category_guid, $user_guid, $category_update_request_body, string $contentType = self::contentTypes['updateCategory'][0])
    {
        return $this->updateCategoryAsyncWithHttpInfo($category_guid, $user_guid, $category_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCategoryAsyncWithHttpInfo
     *
     * Update category
     *
     * @param  string $category_guid The unique id for a &#x60;category&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\CategoryUpdateRequestBody $category_update_request_body Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCategoryAsyncWithHttpInfo($category_guid, $user_guid, $category_update_request_body, string $contentType = self::contentTypes['updateCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryResponseBody';
        $request = $this->updateCategoryRequest($category_guid, $user_guid, $category_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCategory'
     *
     * @param  string $category_guid The unique id for a &#x60;category&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\CategoryUpdateRequestBody $category_update_request_body Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCategoryRequest($category_guid, $user_guid, $category_update_request_body, string $contentType = self::contentTypes['updateCategory'][0])
    {

        // verify the required parameter 'category_guid' is set
        if ($category_guid === null || (is_array($category_guid) && count($category_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_guid when calling updateCategory'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateCategory'
            );
        }

        // verify the required parameter 'category_update_request_body' is set
        if ($category_update_request_body === null || (is_array($category_update_request_body) && count($category_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_update_request_body when calling updateCategory'
            );
        }


        $resourcePath = '/users/{user_guid}/categories/{category_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($category_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'category_guid' . '}',
                ObjectSerializer::toPathValue($category_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($category_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($category_update_request_body));
            } else {
                $httpBody = $category_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateManagedAccount
     *
     * Update managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountUpdateRequestBody $managed_account_update_request_body Managed account object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountResponseBody
     */
    public function updateManagedAccount($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, string $contentType = self::contentTypes['updateManagedAccount'][0])
    {
        list($response) = $this->updateManagedAccountWithHttpInfo($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateManagedAccountWithHttpInfo
     *
     * Update managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountUpdateRequestBody $managed_account_update_request_body Managed account object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateManagedAccountWithHttpInfo($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, string $contentType = self::contentTypes['updateManagedAccount'][0])
    {
        $request = $this->updateManagedAccountRequest($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateManagedAccountAsync
     *
     * Update managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountUpdateRequestBody $managed_account_update_request_body Managed account object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManagedAccountAsync($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, string $contentType = self::contentTypes['updateManagedAccount'][0])
    {
        return $this->updateManagedAccountAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateManagedAccountAsyncWithHttpInfo
     *
     * Update managed account
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountUpdateRequestBody $managed_account_update_request_body Managed account object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManagedAccountAsyncWithHttpInfo($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, string $contentType = self::contentTypes['updateManagedAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountResponseBody';
        $request = $this->updateManagedAccountRequest($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateManagedAccount'
     *
     * @param  string $account_guid The unique id for an &#x60;account&#x60;. (required)
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedAccountUpdateRequestBody $managed_account_update_request_body Managed account object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateManagedAccountRequest($account_guid, $member_guid, $user_guid, $managed_account_update_request_body, string $contentType = self::contentTypes['updateManagedAccount'][0])
    {

        // verify the required parameter 'account_guid' is set
        if ($account_guid === null || (is_array($account_guid) && count($account_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_guid when calling updateManagedAccount'
            );
        }

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling updateManagedAccount'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateManagedAccount'
            );
        }

        // verify the required parameter 'managed_account_update_request_body' is set
        if ($managed_account_update_request_body === null || (is_array($managed_account_update_request_body) && count($managed_account_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $managed_account_update_request_body when calling updateManagedAccount'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'account_guid' . '}',
                ObjectSerializer::toPathValue($account_guid),
                $resourcePath
            );
        }
        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managed_account_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managed_account_update_request_body));
            } else {
                $httpBody = $managed_account_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateManagedMember
     *
     * Update managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberUpdateRequestBody $managed_member_update_request_body Managed member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function updateManagedMember($member_guid, $user_guid, $managed_member_update_request_body, string $contentType = self::contentTypes['updateManagedMember'][0])
    {
        list($response) = $this->updateManagedMemberWithHttpInfo($member_guid, $user_guid, $managed_member_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateManagedMemberWithHttpInfo
     *
     * Update managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberUpdateRequestBody $managed_member_update_request_body Managed member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateManagedMemberWithHttpInfo($member_guid, $user_guid, $managed_member_update_request_body, string $contentType = self::contentTypes['updateManagedMember'][0])
    {
        $request = $this->updateManagedMemberRequest($member_guid, $user_guid, $managed_member_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateManagedMemberAsync
     *
     * Update managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberUpdateRequestBody $managed_member_update_request_body Managed member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManagedMemberAsync($member_guid, $user_guid, $managed_member_update_request_body, string $contentType = self::contentTypes['updateManagedMember'][0])
    {
        return $this->updateManagedMemberAsyncWithHttpInfo($member_guid, $user_guid, $managed_member_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateManagedMemberAsyncWithHttpInfo
     *
     * Update managed member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberUpdateRequestBody $managed_member_update_request_body Managed member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManagedMemberAsyncWithHttpInfo($member_guid, $user_guid, $managed_member_update_request_body, string $contentType = self::contentTypes['updateManagedMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->updateManagedMemberRequest($member_guid, $user_guid, $managed_member_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateManagedMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\ManagedMemberUpdateRequestBody $managed_member_update_request_body Managed member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateManagedMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateManagedMemberRequest($member_guid, $user_guid, $managed_member_update_request_body, string $contentType = self::contentTypes['updateManagedMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling updateManagedMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateManagedMember'
            );
        }

        // verify the required parameter 'managed_member_update_request_body' is set
        if ($managed_member_update_request_body === null || (is_array($managed_member_update_request_body) && count($managed_member_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $managed_member_update_request_body when calling updateManagedMember'
            );
        }


        $resourcePath = '/users/{user_guid}/managed_members/{member_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managed_member_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managed_member_update_request_body));
            } else {
                $httpBody = $managed_member_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMember
     *
     * Update member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberUpdateRequestBody $member_update_request_body Member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function updateMember($member_guid, $user_guid, $member_update_request_body, string $contentType = self::contentTypes['updateMember'][0])
    {
        list($response) = $this->updateMemberWithHttpInfo($member_guid, $user_guid, $member_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateMemberWithHttpInfo
     *
     * Update member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberUpdateRequestBody $member_update_request_body Member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMemberWithHttpInfo($member_guid, $user_guid, $member_update_request_body, string $contentType = self::contentTypes['updateMember'][0])
    {
        $request = $this->updateMemberRequest($member_guid, $user_guid, $member_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateMemberAsync
     *
     * Update member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberUpdateRequestBody $member_update_request_body Member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMemberAsync($member_guid, $user_guid, $member_update_request_body, string $contentType = self::contentTypes['updateMember'][0])
    {
        return $this->updateMemberAsyncWithHttpInfo($member_guid, $user_guid, $member_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMemberAsyncWithHttpInfo
     *
     * Update member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberUpdateRequestBody $member_update_request_body Member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMemberAsyncWithHttpInfo($member_guid, $user_guid, $member_update_request_body, string $contentType = self::contentTypes['updateMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->updateMemberRequest($member_guid, $user_guid, $member_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\MemberUpdateRequestBody $member_update_request_body Member object to be updated (While no single parameter is required, the request body can&#39;t be empty) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMemberRequest($member_guid, $user_guid, $member_update_request_body, string $contentType = self::contentTypes['updateMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling updateMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateMember'
            );
        }

        // verify the required parameter 'member_update_request_body' is set
        if ($member_update_request_body === null || (is_array($member_update_request_body) && count($member_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_update_request_body when calling updateMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($member_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($member_update_request_body));
            } else {
                $httpBody = $member_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTag
     *
     * Update tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagUpdateRequestBody $tag_update_request_body Tag object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TagResponseBody
     */
    public function updateTag($tag_guid, $user_guid, $tag_update_request_body, string $contentType = self::contentTypes['updateTag'][0])
    {
        list($response) = $this->updateTagWithHttpInfo($tag_guid, $user_guid, $tag_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateTagWithHttpInfo
     *
     * Update tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagUpdateRequestBody $tag_update_request_body Tag object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TagResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTagWithHttpInfo($tag_guid, $user_guid, $tag_update_request_body, string $contentType = self::contentTypes['updateTag'][0])
    {
        $request = $this->updateTagRequest($tag_guid, $user_guid, $tag_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TagResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TagResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TagResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTagAsync
     *
     * Update tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagUpdateRequestBody $tag_update_request_body Tag object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTagAsync($tag_guid, $user_guid, $tag_update_request_body, string $contentType = self::contentTypes['updateTag'][0])
    {
        return $this->updateTagAsyncWithHttpInfo($tag_guid, $user_guid, $tag_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTagAsyncWithHttpInfo
     *
     * Update tag
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagUpdateRequestBody $tag_update_request_body Tag object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTagAsyncWithHttpInfo($tag_guid, $user_guid, $tag_update_request_body, string $contentType = self::contentTypes['updateTag'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TagResponseBody';
        $request = $this->updateTagRequest($tag_guid, $user_guid, $tag_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTag'
     *
     * @param  string $tag_guid The unique id for a &#x60;tag&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TagUpdateRequestBody $tag_update_request_body Tag object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTagRequest($tag_guid, $user_guid, $tag_update_request_body, string $contentType = self::contentTypes['updateTag'][0])
    {

        // verify the required parameter 'tag_guid' is set
        if ($tag_guid === null || (is_array($tag_guid) && count($tag_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_guid when calling updateTag'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateTag'
            );
        }

        // verify the required parameter 'tag_update_request_body' is set
        if ($tag_update_request_body === null || (is_array($tag_update_request_body) && count($tag_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag_update_request_body when calling updateTag'
            );
        }


        $resourcePath = '/users/{user_guid}/tags/{tag_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tag_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tag_guid' . '}',
                ObjectSerializer::toPathValue($tag_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tag_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tag_update_request_body));
            } else {
                $httpBody = $tag_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTagging
     *
     * Update tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingUpdateRequestBody $tagging_update_request_body Tagging object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TaggingResponseBody
     */
    public function updateTagging($tagging_guid, $user_guid, $tagging_update_request_body, string $contentType = self::contentTypes['updateTagging'][0])
    {
        list($response) = $this->updateTaggingWithHttpInfo($tagging_guid, $user_guid, $tagging_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateTaggingWithHttpInfo
     *
     * Update tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingUpdateRequestBody $tagging_update_request_body Tagging object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTagging'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TaggingResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaggingWithHttpInfo($tagging_guid, $user_guid, $tagging_update_request_body, string $contentType = self::contentTypes['updateTagging'][0])
    {
        $request = $this->updateTaggingRequest($tagging_guid, $user_guid, $tagging_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TaggingResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TaggingResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TaggingResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTaggingAsync
     *
     * Update tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingUpdateRequestBody $tagging_update_request_body Tagging object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaggingAsync($tagging_guid, $user_guid, $tagging_update_request_body, string $contentType = self::contentTypes['updateTagging'][0])
    {
        return $this->updateTaggingAsyncWithHttpInfo($tagging_guid, $user_guid, $tagging_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaggingAsyncWithHttpInfo
     *
     * Update tagging
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingUpdateRequestBody $tagging_update_request_body Tagging object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaggingAsyncWithHttpInfo($tagging_guid, $user_guid, $tagging_update_request_body, string $contentType = self::contentTypes['updateTagging'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TaggingResponseBody';
        $request = $this->updateTaggingRequest($tagging_guid, $user_guid, $tagging_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTagging'
     *
     * @param  string $tagging_guid The unique id for a &#x60;tagging&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\TaggingUpdateRequestBody $tagging_update_request_body Tagging object to be updated with required parameter (tag_guid) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTagging'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTaggingRequest($tagging_guid, $user_guid, $tagging_update_request_body, string $contentType = self::contentTypes['updateTagging'][0])
    {

        // verify the required parameter 'tagging_guid' is set
        if ($tagging_guid === null || (is_array($tagging_guid) && count($tagging_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagging_guid when calling updateTagging'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateTagging'
            );
        }

        // verify the required parameter 'tagging_update_request_body' is set
        if ($tagging_update_request_body === null || (is_array($tagging_update_request_body) && count($tagging_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tagging_update_request_body when calling updateTagging'
            );
        }


        $resourcePath = '/users/{user_guid}/taggings/{tagging_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tagging_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'tagging_guid' . '}',
                ObjectSerializer::toPathValue($tagging_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tagging_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tagging_update_request_body));
            } else {
                $httpBody = $tagging_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUser
     *
     * Update user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\UserUpdateRequestBody $user_update_request_body User object to be updated (None of these parameters are required, but the user object cannot be empty.) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserResponseBody
     */
    public function updateUser($user_guid, $user_update_request_body, string $contentType = self::contentTypes['updateUser'][0])
    {
        list($response) = $this->updateUserWithHttpInfo($user_guid, $user_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateUserWithHttpInfo
     *
     * Update user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\UserUpdateRequestBody $user_update_request_body User object to be updated (None of these parameters are required, but the user object cannot be empty.) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserWithHttpInfo($user_guid, $user_update_request_body, string $contentType = self::contentTypes['updateUser'][0])
    {
        $request = $this->updateUserRequest($user_guid, $user_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UserResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UserResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateUserAsync
     *
     * Update user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\UserUpdateRequestBody $user_update_request_body User object to be updated (None of these parameters are required, but the user object cannot be empty.) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAsync($user_guid, $user_update_request_body, string $contentType = self::contentTypes['updateUser'][0])
    {
        return $this->updateUserAsyncWithHttpInfo($user_guid, $user_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserAsyncWithHttpInfo
     *
     * Update user
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\UserUpdateRequestBody $user_update_request_body User object to be updated (None of these parameters are required, but the user object cannot be empty.) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAsyncWithHttpInfo($user_guid, $user_update_request_body, string $contentType = self::contentTypes['updateUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UserResponseBody';
        $request = $this->updateUserRequest($user_guid, $user_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUser'
     *
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  \OpenAPI\Client\Model\UserUpdateRequestBody $user_update_request_body User object to be updated (None of these parameters are required, but the user object cannot be empty.) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserRequest($user_guid, $user_update_request_body, string $contentType = self::contentTypes['updateUser'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling updateUser'
            );
        }

        // verify the required parameter 'user_update_request_body' is set
        if ($user_update_request_body === null || (is_array($user_update_request_body) && count($user_update_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_update_request_body when calling updateUser'
            );
        }


        $resourcePath = '/users/{user_guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_update_request_body));
            } else {
                $httpBody = $user_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfileGet
     *
     * Read monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MonthlyCashFlowResponseBody
     */
    public function usersUserGuidMonthlyCashFlowProfileGet($user_guid, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'][0])
    {
        list($response) = $this->usersUserGuidMonthlyCashFlowProfileGetWithHttpInfo($user_guid, $contentType);
        return $response;
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfileGetWithHttpInfo
     *
     * Read monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MonthlyCashFlowResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUserGuidMonthlyCashFlowProfileGetWithHttpInfo($user_guid, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'][0])
    {
        $request = $this->usersUserGuidMonthlyCashFlowProfileGetRequest($user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfileGetAsync
     *
     * Read monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUserGuidMonthlyCashFlowProfileGetAsync($user_guid, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'][0])
    {
        return $this->usersUserGuidMonthlyCashFlowProfileGetAsyncWithHttpInfo($user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfileGetAsyncWithHttpInfo
     *
     * Read monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUserGuidMonthlyCashFlowProfileGetAsyncWithHttpInfo($user_guid, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody';
        $request = $this->usersUserGuidMonthlyCashFlowProfileGetRequest($user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUserGuidMonthlyCashFlowProfileGet'
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUserGuidMonthlyCashFlowProfileGetRequest($user_guid, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfileGet'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling usersUserGuidMonthlyCashFlowProfileGet'
            );
        }


        $resourcePath = '/users/{user_guid}/monthly_cash_flow_profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfilePut
     *
     * Update monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  \OpenAPI\Client\Model\MonthlyCashFlowProfileRequestBody $monthly_cash_flow_profile_request_body monthly_cash_flow_profile_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MonthlyCashFlowResponseBody
     */
    public function usersUserGuidMonthlyCashFlowProfilePut($user_guid, $monthly_cash_flow_profile_request_body, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'][0])
    {
        list($response) = $this->usersUserGuidMonthlyCashFlowProfilePutWithHttpInfo($user_guid, $monthly_cash_flow_profile_request_body, $contentType);
        return $response;
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfilePutWithHttpInfo
     *
     * Update monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  \OpenAPI\Client\Model\MonthlyCashFlowProfileRequestBody $monthly_cash_flow_profile_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MonthlyCashFlowResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUserGuidMonthlyCashFlowProfilePutWithHttpInfo($user_guid, $monthly_cash_flow_profile_request_body, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'][0])
    {
        $request = $this->usersUserGuidMonthlyCashFlowProfilePutRequest($user_guid, $monthly_cash_flow_profile_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfilePutAsync
     *
     * Update monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  \OpenAPI\Client\Model\MonthlyCashFlowProfileRequestBody $monthly_cash_flow_profile_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUserGuidMonthlyCashFlowProfilePutAsync($user_guid, $monthly_cash_flow_profile_request_body, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'][0])
    {
        return $this->usersUserGuidMonthlyCashFlowProfilePutAsyncWithHttpInfo($user_guid, $monthly_cash_flow_profile_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUserGuidMonthlyCashFlowProfilePutAsyncWithHttpInfo
     *
     * Update monthly cash flow profile
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  \OpenAPI\Client\Model\MonthlyCashFlowProfileRequestBody $monthly_cash_flow_profile_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUserGuidMonthlyCashFlowProfilePutAsyncWithHttpInfo($user_guid, $monthly_cash_flow_profile_request_body, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MonthlyCashFlowResponseBody';
        $request = $this->usersUserGuidMonthlyCashFlowProfilePutRequest($user_guid, $monthly_cash_flow_profile_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUserGuidMonthlyCashFlowProfilePut'
     *
     * @param  string $user_guid The unique identifier for the user. (required)
     * @param  \OpenAPI\Client\Model\MonthlyCashFlowProfileRequestBody $monthly_cash_flow_profile_request_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUserGuidMonthlyCashFlowProfilePutRequest($user_guid, $monthly_cash_flow_profile_request_body, string $contentType = self::contentTypes['usersUserGuidMonthlyCashFlowProfilePut'][0])
    {

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling usersUserGuidMonthlyCashFlowProfilePut'
            );
        }

        // verify the required parameter 'monthly_cash_flow_profile_request_body' is set
        if ($monthly_cash_flow_profile_request_body === null || (is_array($monthly_cash_flow_profile_request_body) && count($monthly_cash_flow_profile_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $monthly_cash_flow_profile_request_body when calling usersUserGuidMonthlyCashFlowProfilePut'
            );
        }


        $resourcePath = '/users/{user_guid}/monthly_cash_flow_profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($monthly_cash_flow_profile_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($monthly_cash_flow_profile_request_body));
            } else {
                $httpBody = $monthly_cash_flow_profile_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
        /**
     * Operation verifyMember
     *
     * Verify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MemberResponseBody
     */
    public function verifyMember($member_guid, $user_guid, string $contentType = self::contentTypes['verifyMember'][0])
    {
        list($response) = $this->verifyMemberWithHttpInfo($member_guid, $user_guid, $contentType);
        return $response;
    }

    /**
     * Operation verifyMemberWithHttpInfo
     *
     * Verify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMember'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MemberResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyMemberWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['verifyMember'][0])
    {
        $request = $this->verifyMemberRequest($member_guid, $user_guid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MemberResponseBody',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MemberResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation verifyMemberAsync
     *
     * Verify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyMemberAsync($member_guid, $user_guid, string $contentType = self::contentTypes['verifyMember'][0])
    {
        return $this->verifyMemberAsyncWithHttpInfo($member_guid, $user_guid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyMemberAsyncWithHttpInfo
     *
     * Verify member
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyMemberAsyncWithHttpInfo($member_guid, $user_guid, string $contentType = self::contentTypes['verifyMember'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MemberResponseBody';
        $request = $this->verifyMemberRequest($member_guid, $user_guid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyMember'
     *
     * @param  string $member_guid The unique id for a &#x60;member&#x60;. (required)
     * @param  string $user_guid The unique id for a &#x60;user&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function verifyMemberRequest($member_guid, $user_guid, string $contentType = self::contentTypes['verifyMember'][0])
    {

        // verify the required parameter 'member_guid' is set
        if ($member_guid === null || (is_array($member_guid) && count($member_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_guid when calling verifyMember'
            );
        }

        // verify the required parameter 'user_guid' is set
        if ($user_guid === null || (is_array($user_guid) && count($user_guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_guid when calling verifyMember'
            );
        }


        $resourcePath = '/users/{user_guid}/members/{member_guid}/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($member_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'member_guid' . '}',
                ObjectSerializer::toPathValue($member_guid),
                $resourcePath
            );
        }
        // path params
        if ($user_guid !== null) {
            $resourcePath = str_replace(
                '{' . 'user_guid' . '}',
                ObjectSerializer::toPathValue($user_guid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/vnd.mx.api.v1+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
